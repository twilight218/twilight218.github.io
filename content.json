{"pages":[],"posts":[{"title":"Collection","text":"本篇文章记录学习java集合中Collection接口的内容。 $Collection$接口 $Collection$​接口是$List、Set和Queue$​​接口的父接口，该接口里定义的方法既可操作$Set$​集合，也可用于操作$List$​和$Queue$​集合。 $jdk$​不提供此接口的任何直接实现，而是提供更具体的子接口(如$Set,List$​)实现。 在$java5$​之前，$java$​集合会丢失容器中所有对象的数据类型，把所有对象都当成$Object$​类型处理；从$jdk5.0$​增加了泛型之后，$java$​集合可以记住容器中对象的数据类型。 $Iterator$​迭代器接口 $Iterator$对象称为迭代器(设计模式的一种)，主要用于遍历$Collection$集合中的元素。 $Collection$接口继承了$java.lang.Iterator$接口，该接口有一个$iterator()$方法，那么所有实现了$Collection$接口的集合类都能调用$iterator()$方法，返回一个实现了$Iterator$接口的对象。 $Iterator$​仅用于遍历集合，$Iterator$本身并不提供承装对象的能力。如果需要创建$Iterator$对象，则必须有一个被迭代的集合。 集合对象每次调用$iterator()$​方法都会得到一个全新的对象，默认指向集合第一个元素之前。 $List$接口 $List$集合类中元素有序，且可重复，集合中每个元素都有其对应的顺序索引。 List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号调用$get()$​方法取容器中的元素。 $List$接口的常用实现类有$ArrayList、LinkedList$和$Vector$​. $ArrayList$$jdk7$​​​​1ArrayList list = new ArrayList(); 在调用空参构造器时，创建了长度为$10$的$Object[]$数组$elementData$。当向$list$中增加元素达到$11$个时，数组容量不够，需要扩容，默认情况下，是扩容到原来的$1.5$倍，同时需要将原有数据中的数据复制到新的数组中。 $jdk8$​​​​底层$Object[] elementData$​​​初始化空，当调用空参构造器时，并没有创建长度为$10$​数组。当第一次调用$add()$​时，才创建长度为$10$​的数组，并将数组添加到数组中。 这种创建对象的方式类似于单例的饿汉式，延迟了数组的创建，节省内存。 具体创建的方法为$grow()$，这也是扩容的方法。 1234567891011121314151617/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);} 可以直接调用设置数组大小的构造器public ArrayList(int initialCapacity) $ArrayList$是线程不安全的，效率较高 $LinkedList$$LinkedList$底层使用双向链表实现，内部没有声明数组，而是定义了$Node$类型的$first$和$last$,用于记录首末元素。同时定义内部类$Node$，作为保存数据的基本结构。 1234567891011private static class Node&lt;E&gt; { E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) { this.item = element; this.next = next; this.prev = prev; }} 对于频繁的插入和删除元素操作，使用$LinkedList$效率比$ArrayList$高。 $Vector$在$jdk7$​和$jdk8$​中创建$Vector$​对象，都创建了长度为$10$​​的数组。在扩容方面，默认扩容为原来数组长度的两倍。 大多数操作都和$ArrayList$​相同，区别在于$Vector$​​是线程安全的,它总是比$ArrayList$​慢，应避免使用。 $Stack$是$Vector$的子类。 $Set$接口 $Set$接口$Collection$的子接口，没有提供额外的方法，不允许包含相同的元素。 $Set$判断两个对象是否相同是根据$equals()$方法。 $HashSet$$HashSet$​的内部采用了$HashMap$​作为数据存储，$HashSet$​其实就是在操作$HashMap$​的$key$​。 1234567/** * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has * default initial capacity (16) and load factor (0.75). */public HashSet() { map = new HashMap&lt;&gt;();} 关于$hashMap$，可查看map $LinkedHashSet$​是$HashSet$的子类，根据元素的$hashCode$​值来决定元素存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的。​ $LinkedHashSet$插入性能略低于$HashSet$，但在迭代访问$Set$全部元素时有很好的性能。 $TreeSet$ 是$SortedSet$接口的实现类，可以确保集合元素处于排序状态。 底层使用红黑树结构存储数据。 两种排序方法：自然排序(集合元素需实现$Comparable$接口，重写$CompareTo()$方法)；定制排序(传入一个实现了$Comparator$接口重写$Compare()$方法的实例) $Collections$工具类 是一个操作$Set、List、Map$等集合的工具类 提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法","link":"/2021/11/23/Collection/"},{"title":"Hello Blog","text":"2021年10月21日，我终于开通了个人博客。 让我下定决心写博客的原因，是在昨天下午做到求数组中和为k的子数组个数的题目时，用到前缀和+哈希表，而这道题让我想起8月28号的CCPC网络赛F题Command Sequence也是一道前缀和+哈希表的题目，那时我却没有做出来，意识到自己已经打了将近半年的acm，知识还是很混乱的，所以下决心记录梳理一下知识。","link":"/2021/10/21/Hello-Blog/"},{"title":"Map","text":"本篇文章记录学习$java$​集合中$Map$接口的内容。 $Map$接口 $Map$与$Collection$并列存在，存储具有映射关系的数据：key-value; $Map$中的$key$用$set$​来存放，不允许包含同样的值。同一个$Map$对象实现的类，必须重写$equals()$和$hashCode()$方法。 $Map$中常使用$String$作为键。 常用实现类有$HashMap、LinkedHashMap、HashTable、Properties$，子接口$SortedMap$，其实现类$TreeMap$。 $HashMap$源码中的重要常量 123456789101112//默认初始化容量为16，必须是2的n次幂static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;//最大容量为2^30static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;//默认加载因子是0.75static final float DEFAULT_LOAD_FACTOR = 0.75f;//当链表长度过长时，超过这个阈值会转化为红黑树static final int TREEIFY_THRESHOLD = 8;//当红黑树上的元素个数减少到6个是，转化为链表static final int UNTREEIFY_THRESHOLD = 6;//链表转化成红黑树时数组的最小长度，这是为了避免数组扩容和树化的冲突static final int MIN_TREEIFY_CAPACITY = 64; $jdk7$HashMap的内部存储是数组加链表的结合。当实例化一个HashMap对象时，会创建一个长度为Capacity的Entry数组，在这个数组中存放元素的位置称之为桶($bucket$​)，每个$bucket$​有自己的索引，可以根据索引找到其在数组中的位置。 关于put首先调用key所在类的hashCode()和hash方法计算key的哈希值，$jdk7$为了防止因$hash$碰撞引发的问题，在计算$hash$过程中引入随机种子，以增强$hash$的随机性，使得键值对均匀分布在桶数组中。 $hash$方法 12345678910final int hash(Object k) { int h = hashSeed; if (0 != h &amp;&amp; k instanceof String) { return sun.misc.Hashing.stringHash32((String) k); } h ^= k.hashCode(); // 通过多次位运算，提高算法散列性 h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);} 然后根据得到的$h$值和$table$的长度计算出在$table$​中的下标i=h&amp;(length-1). 如果该位置上为空，则$key-value$​添加成功。 若不为空，意味着此位置存在一个或多个数据(以链表形式存在)，需要比较$key$和已经存在的数据的哈希值。 如果$key$的哈希值与已经存在的数据的哈希值都不相同，那么$key-value$​添加成功，和原来的数据以链表的方式存储，且使用的是头插法，可能是出于后来的数据被访问到的可能性更大的出发点。 如果$key$的哈希值和已经存在的某一个数据$key1$的哈希值相同，继续调用$key$所在类的$equals()$方法比较是否相等。若不相等，则添加成功。如果相等，则用新的$value$更新原来的$value$​。 $hashMap$​​的扩容当数组中元素数量达到扩容阈值$threshold$时，需要对原数组进行扩容，这便是$resize()$。数组的大小会扩展为$16*2=32$，即扩大一倍，并且需要重新计算每个元素在数组中的位置，这是一个很消耗时间的操作。 $resize()$方法 123456789101112131415void resize(int newCapacity) { Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return; } //创建新数组 Entry[] newTable = new Entry[newCapacity]; //将原table中的元素转移到新table中 transfer(newTable, initHashSeedAsNeeded(newCapacity)); table = newTable; //重新计算扩容阈值 threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);} $transfer()$方法 12345678910111213141516//转移元素void transfer(Entry[] newTable, boolean rehash) { int newCapacity = newTable.length; for (Entry&lt;K,V&gt; e : table) { while(null != e) { Entry&lt;K,V&gt; next = e.next; if (rehash) { e.hash = null == e.key ? 0 : hash(e.key); } int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; } }} 可以看到重新计算元素在数组中的位置仍需要调用$hash()$函数，这一点在$jdk1.8$​有所改进。 为什么不直接复制到新数组中？因为数组下标计算公式为hash(key)&amp;(length-1),当数组长度变化，数组所在位置也应该变化。 头插法的弊端使用头插，当数组扩容，链表上的元素顺序会倒置，在多线程环境下可能形成环。 在多线程的环境下有可能会使链表形成环状，在$getEntry()$​​​​方法查找元素时导致死循环。 $jdk8$在$jdk8$中$hashMap$​的内部存储结构是数组+链表+红黑树的结合。$jdk8$中的数组是$Node$类型的，这与$jdk7$​不同。当初始化一个$hashMap$时，会初始化initialCapacity和loadFactor，在$put$​第一对映射关系时，会创建一个长度为initialCapacity的$Node$数组，这个长度是容量Capacity,在数组中存放元素的位置称之为桶(bucket),每个bucket有自己的索引，可根据索引查找到bucket中的元素。 为什么初始化数组长度为$16$​​当$put$一个新数据时会计算位于$table$​​数组中的下标index = hash(key)&amp;(length-1)，此处求下标使用按位与操作，如果$length-1$中某一位为$0$，那么该位按位与&amp;必然为$0$，导致数组上有些位置永远访问不到，造成空间的浪费，也增加了$hash$​冲突的可能性。而如果是$2$的$n$次幂形式，减一后低位全为$1$​，保证计算后的$index$既可以是奇数也可以是偶数，且只要传进来的$key$足够分散均匀，那么$index$就会减少重复，这样就减少了$hash$​碰撞。 为什么选$16$这个数？因为分配的太小很容易导致$Map$​扩容影响性能，初始化分配太大又会浪费资源。 加载因子$0.75$​​是时间和空间的权衡。如果小于$0.75$如$0.5$，那么数组达到一半就会扩容，空间利用率大大降低。如果大于$0.75$如$0.8$，则会增大$hash$​​冲突的概率，影响查询效率。在源码注释中有更深层次解释，大概意思是当加载因子是$0.75$的情况下，桶中$Node$结点的分布服从参数为$0.5$的泊松分布，当一个桶中出现$8$个元素的概率，已经小于千万分之一了。 12345678910111213141516171819202122232425/** Because TreeNodes are about twice the size of regular nodes, we * use them only when bins contain enough nodes to warrant use * (see TREEIFY_THRESHOLD). And when they become too small (due to * removal or resizing) they are converted back to plain bins. In * usages with well-distributed user hashCodes, tree bins are * rarely used. Ideally, under random hashCodes, the frequency of * nodes in bins follows a Poisson distribution * (http://en.wikipedia.org/wiki/Poisson_distribution) with a * parameter of about 0.5 on average for the default resizing * threshold of 0.75, although with a large variance because of * resizing granularity. Ignoring variance, the expected * occurrences of list size k are (exp(-0.5) * pow(0.5, k) / * factorial(k)). The first values are: * * 0: 0.60653066 * 1: 0.30326533 * 2: 0.07581633 * 3: 0.01263606 * 4: 0.00157952 * 5: 0.00015795 * 6: 0.00001316 * 7: 0.00000094 * 8: 0.00000006 * more: less than 1 in ten million */ $put()$​​方法123public V put(K key, V value) { return putVal(hash(key), key, value, false, true);} 当$table$为空时调用$resize()$扩容。根据当前$key$的哈希值找到在数组中的下标，并判断当前位置是否存在元素，若没有，则把$key、value$包装成$Node$节点，直接添加到此位置。若已有元素，分三种情况。 当前位置元素的$hash$值等于传过来的$hash$值，且它们的$key$​也相等，就覆盖。 如果当前已经是红黑树结果，就加入到红黑树中。 已存在元素，且是普通链表结构，则采用尾插法，把新节点加入到链表尾部。在插入过程中，若链表长度达到$8$，则转化为红黑树。 $hashMap$​​的扩容和$hash$​​方法当数组元素个数超过initialCapacity*loadFactor时，就会进行数组扩容，将数组容量扩大一倍。 $hash$方法 12345static final int hash(Object key) { int h; // &gt;&gt;&gt;无符号右移，只保留高16位 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);} 将$hashCode()$的值进行高$16$位值和低$16$值的异或运算，尽量保留高$16$位的特征，降低哈希碰撞的概率。如果不进行高低位异或运算，直接用低$16$​位和n-1相与求数组下标，那么高位不同，低位相似度较高的两个$hashCode$值得到的数组下标可能相同，高位的特征被丢失了，这样哈希碰撞的概率大大增加。而异或运算，使$0$和$1$的比例达到$1:1$的平衡状态，使结果的随机性更大。 在$resize()$​​扩大数组长度为两倍后，重新计算原数组的位置时，如果原来的$hash$值在高$1$位为$0$，那么在新数组的位置不变，如果为$1$​，则在新数组中的位置为原来的位置加上原来数组的长度。 这样在扩充时不需要像$jdk1.7$那样重新计算$hash$,只需要看看原来的$hash$新增的那个$bit$是$1$还是$0$即可，省去了重新计算$hash$的时间，这是优化的地方。 且$jdk1.7$中$rehash$时，旧链表迁移到新链表时，如果在新表的数组索引位置相同，则链表元素会倒置，可能形成环，而$jdk1.8$中使用尾插法不会使元素倒置倒置，在$resize()$​​中有所体现。 $hashMap$​​的树化在$put$数据到$hashMap$中时，如果是放到同一个位置上链表里，当链表长度达到$8$​​，会进行树化。会什么是$8$，在$jdk1.8$的源码注释中有深层次的解释，涉及泊松分布等概率知识，和上文加载因子$0.75$一致。 12if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); 但是，当数组长度小于$64$，会先进行扩容。如果数组长度达到了64，就转变为红黑树结构，结点类型由$Node$变成$TreeNode$类型。当元素被移除时，下次$resize()$方法判断树的结点个数低于$6$个，会将红黑树再转变为链表。 带参构造器当希望指定初始数组的大小时，调用了带有数组大小参数的构造器，但并不会真正创建那个长度的数组。由上文所讲，数组长度必须为$2$的$n$次幂形式。实际上会使用到$tableSizeFor()$函数，返回大于当前传入值最小的一个$2$的$n$次幂的值。 123456789101112/** * Returns a power of two size for the given target capacity. */static final int tableSizeFor(int cap) { int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;} $hashMap$​​是线程安全的吗？不是，即使在扩容时不会引起死循环，但$put()$和$get()$方法都没有加同步锁，在多线程的情况下，无法保证上一秒$put$的值，下一秒$get$的仍是原值。 $Node$节点里的$hashCode$方法。 123public final int hashCode() { return Objects.hashCode(key) ^ Objects.hashCode(value);} $LinkedHashMap$ 是$hashMap$的子类，在$hashMap$的存储结构基础上，使用了一对双向链表来记录添加元素的顺序。 和$LinkedHashSet$类似，可以维护$map$的迭代顺序与插入顺序一致。 内部类$Entry$ 123456static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; { Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) { super(hash, key, value, next); }} $TreeMap$ 存储$key-value$对时，会根据$key$进行排序。 使用自然排序，所有的$key$必须是同一个类的对象，并且实现$Comparable$接口 使用定制排序，创建$TreeMap$时需要传入一个$Comparator$对象，负责对$key$排序。 判断两个$key$相等的标准：通过$compareTo()$方法或者$compare()$方法返回$0$。 $HashTable$ 是一个古老的$Map$实现类，实现原理和$hashMap$相同，但是方法直接加上$synchronized$，是线程安全的。 $hashTable$不允许将$null$作为$key$或者$value$，而$hashMap$允许。 效率比$hashMap$​低，一般不使用。在多线程环境下会使用$ConcurrentHashMap$。","link":"/2021/11/24/Map/"},{"title":"位运算","text":"本篇文章主要罗列一些位运算的技巧，加强记忆。 消去$x$二进制位的最后一位$1$​​​​​​ ：x&amp;(x-1) 判断$x$是否是$2$的幂 ：x&amp;(x-1)==0 判断数$x$的二进制有几个$1$ ：每次去掉最低位$1$，统计次数 两个数$a,b$，$a\\bigoplus b\\bigoplus b=a$​,一个数异或两次另一个数得到自身，由异或运算满足结合律很好理解。 不设中间值，交换两个变量$a,b$​的值 : a=a^b,b=a^b,a=a^b. a^b&lt;=a+b 例题：永夜的报应 取余操作$a\\pmod b$​，当除数$b$​为$2^n$​​​​​​​​形式，可以转化为a&amp;(b-1)​​,效率更高。 暂时想到这么多，，，","link":"/2021/11/05/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"title":"关于equals和hashCode方法","text":"本篇文章记录学习$equals()$方法和$hashCode()$方法的内容。 什么是$hashCode$通常所说的$hashCode$是一个经过哈希运算后的整型值，这个哈希运算的方法，定义在$Object$类中，通过一个本地方法$hashCode()$来实现(在$hashMap$中还会有一些其他的运算)。 1public native int hashCode(); 要了解这个方法到底是什么作用，最有效的方法就是直接看源码注释。 返回当前对象的一个哈希值。这个方法用于支持一些哈希表，例如$hashMap$。 通常来讲，它有一下一些约定： 若对象的信息没有被修改，那么，在一个程序的执行期间，对于相同的对象，不管调用多少次$hashCode$方法，都应该返回相同的值。当然，在相同程序的不同执行期间，不需要保持结果的一致。 若两个对象的$equals()$方法返回值相同，那么，他们调用各自的$hashCode$方法时，也必须返回相同的结果。 当两个对象的$equals()$方法返回值不同时，那么他们的$hashCode$方法不用保证必须返回不同的值。但是，我们应该知道，在这种情况下，最好也设计成$hashCode$返回不同的值。因为，这样做有助于提高哈希表的性能。 实际情况下，$Object$类的$hashCode$方法在不同的对象确实返回了不同的哈希值。这通常是通过把对象的内部地址转换成一个整数来实现的。 这里所说的内部地址就是物理地址。需要注意的是，虽然$hashCode$值是依据它的物理地址而得来的。但是，不能说$hashCode$就代表对象的内存地址。 $hashCode$有什么用在哈希表中，通过$key$计算出它的$hashCode$​值，再进行处理就可以确定它在哈希表中的位置，这样，在查询时，就可以直接定位到当前元素，提高查询效率。对于要插入的一个新元素，先去计算它的$hashCode$​值，如果此位置没有元素，那么就直接插入即可。如果此位置已经有值，可以通过$equals()$方法比较它们是否相等，不等则也插入到这个位置(可以用链表形式存放)。所以，$hashCode$提高了查询，插入元素的效率。 $equals$和$==$的区别$equals$比较的是内容，而 == 比较的是地址。 $equals()$方法是定义在$Object$类中的。 123public boolean equals(Object obj) { return (this == obj);} 可以看到，它的默认实现，就是 == ，用来比较两个对象的内存地址是否相等。如果一个对象不重写$equals$​，那么效果和 == 是一样的。 因此，在使用自定义类的对象时，如果要让两个对象的内容相同时认为对象时相同的，则需要重写$equals$方法。 为什么要重写$equals$和$hashCode$前面已经说明为什么重写$equals$，重写$hashCode$就涉及到$Map$和$Set$(底层其实也是$Map$)的内容了。 以$hashMap$ $jdk1.8$的源码来看，如$put$方法。 可以看到，在插入元素时，代码中多次进行$hash$​值的比较，只有当$hash$​值相等时，才会去比较$equals()$方法。当哈希值和$equals$比较都相等时，才会覆盖元素。$get$​方法也是如此。 只有当$hashCode$和$equals$都相等时，才认为是同一个元素。 重写$hashCode$和$equals$的目的，就是为了方便哈希表这样的结构快速的查询和插入，不重写，则无法比较元素，可能造成元素位置错乱。 重写了$equals$，就必须重写$hashCode$在$JDK$​源码注释第二点就说明了这一点。如果不重写$hashCode$​，对于我们自定义的类，创建的两个内容相同的对象，将其中一个对象加入到$hashmap$中，另一个对象调用其$hashCode$查找位置仍能插入成功，这是不正确的。 还需要注意的是，讲对象插入到了$hashMap$后，不要在使用过程中，改变对象的值，这样会导致$hashCode$值发生改变，无法再获取到插入的值。 $String$类具有不可变性，所以我们经常使用$String$类作为$hashMap$的$key$​值。 $hashCode$相等，$equals$一定相等吗显然不是。在源码中，当通过$hashCode$值处理后计算出来的位置相等(产生哈希碰撞)时，还需要比较它们的$equals$​，才能确定是否是同一个对象。因此，$hashCode$​相等时，$equals$不一定相等。 反过来，$equals$相等，那么$hashCode$一定相等吗？是一定的。$equals$都相等了，那么在$hashMap$中认为它们是同一个元素，那么$hashCode$值必须保证相等。 总结 $hashCode$相等，$equals$不一定相等 $hashCode$不等，$equals$一定不等 $equals$相等，$hashCode$一定相等 $equals$不等，$hashCode$不一定不等 在源码注释第三点也提到，当$equals$不等时。不必保证它们的$hashCode$不等。但是为了提高哈希表的效率，最好设计成不等。因为，我们既然知道它们不相等了，那么当 $hashCode$ 设计成不等时。只要比较$hashCode$ 不相等，我们就可以直接返回 $null$，而不必再去比较 $equals$了。这样，就减少了比较的次数，无疑提高了效率。","link":"/2021/11/25/%E5%85%B3%E4%BA%8Eequals%E5%92%8ChashCode%E6%96%B9%E6%B3%95/"},{"title":"图论(1)","text":"TarjanTarjan算法是一种非常实用的图论算法，可以解决连通块、割点、缩点、桥等问题。 建图建图采用链式前向星方式。 12345678910111213141516171819int head[maxn]; //表头int nxt[maxn]; //链表下一位int edge[maxn]; //该边终点int weight[maxn]; //该边的权值int tot; //边的数量void addEdge(int u,int v,int w){ edge[++tot] = v; weight[tot] = w; nxt[tot] = head[u]; head[u] = tot;}//遍历方式void traverse(){ for(int i=1;i&lt;=n;i++) for(int j=head[i];j;j=nxt[j]) cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;edge[j]&lt;&lt;endl;} 强连通分量强连通分量，即图的一个子集。如果两个顶点可以相互通达，则称这两个点强连通(strongly connected).如果有向图的每两个顶点都强连通，则称图G为强连通图。有向图的强连通子图，称为强连通分量。 弄懂Tarjan算法需要明白最重要的两个数组：$dfn、low$​​. $dfn[x]$​​记录每个点最早被遍历的时间，即在dfs过程中$x$的时间戳。 $low[x]$​​​表示从$x$​​处搜索，能够回溯到的最早被遍历的点的时间戳。 用$vis$数组来记录每个点的分块编号，或者换个写法表示每个点所在的连通块的根的编号也可。 使用dfs遍历图，每次访问到新节点$u$​时，向栈中压入$u$​，记录$dfn[u]==low[u]$​，并依次访问该节点的每一个相邻节点$v$​.会出现三种情况： $dfn[v]==0$:此时$v$​​还没有搜索到，直接对$v$​进行递归，会得到$low[v]$​,故更新$low[u] = min(low[u],low[v])$​​ $vis[v]==0$:此时$v$​早在$u$​之前就已经访问过了，但是$u$​的邻接点还未遍历完全，更新$low[u]=min(low[u],dfn[v])$​. $vis[v]!=0$:此时$v$已经操作完全，略过。 对于第二种情况的$v$​，我们用其$dfn$值更新$u$的$low$值的原因是，从$u$处能搜到曾经搜过的$v$，那么从$v$开始就有可能存在一个强联通块包含了$u$，因此我们将$u$的low值更新，再通过回溯时对low值的更新，一步步更新回$v$点，若$low[v]$与$dfn[v]$相等，就说明从$v$开始绕了一圈又找到了$v$，也就是说找到了强连通分量。那么如何对应地找到其中所有的节点呢？我们通过栈来实现，在dfs过程中，若遇到没搜过的点，则将其入栈，最后在$low[u]=dfn[u]$处，因为从$u$处最终能走回$u$，回溯到$u$​时，途中的所有节点都在栈中，而中途可能遇到的分支都会在相同的过程中全部出栈（不在环中的自成一个强连通分量），因此从栈顶到栈中$u$的位置，中间的节点正好在一个强连通分量中，所以我们只需要不断弹栈，直到将$u$弹出栈，所有弹出的元素都归为一个强联通块中。可以证明，这样求得的强联通块是最大强联通块，将强联通块抽象成点，这便是缩点 12345678910111213141516171819202122232425void Tarjan(int u){ dfn[u] = low[u] = ++tit; //时间戳 st.push(u); for(int i=head[u];i;i=nxt[i]) { int v = edge[i]; if(!dfn[v]){ Tarjan(v); low[u] = min(low[u],low[v]); } else if(!vis[v]) low[u] = min(low[u],dfn[v]); } if(dfn[u]==low[u]) { vis[u] = ++cnt; //连通块编号 while(st.top()!=u) { vis[st.top()] = cnt; //栈顶到u的一块都在一个连通块中 st.pop(); } st.pop(); }} 上题目校园网 缩点 割点割点是指若将连通图的某个点及其连接的边删去后，图中的连通分量增加，则称这个点为割点。 对于点$u$，假如其从$fa$搜索而来，连接着某点$v$,若$low[v] \\geq dfn[u]$,则$u$​是割点。 可以画出图来理解，如果我们将$u$和其连接的边删掉，$v$和$fa$必然不属于同一个连通块。若删掉后$v$和$fa$属于同一个连通块，那么$low[v]$必然会小于$dfn[u]$。通过这一点我们可以对每个走过的点都用其$dfn$值更新$u$的$low$值，就是为了保证求出的割点一定保证$fa$和$v$不在任何同一个连通块中。 那么这时我们会考虑一个特殊的点：第一个被搜索的点，这个点没有$fa$。该如何确定这个点是不是割点呢？我们直接记录其子树数量，如果其子树数量大于1，那么就是割点，因为把它去掉，其子树不能相互到达。 于是算法模板如下 12345678910111213141516171819202122void tarjan(int u,int root){ dfn[u] = low[u] = ++tit; int childtree = 0; //根的子树数量 for(int i=head[u];i;i=e[i].nxt) { int v = e[i].to; if(!dfn[v]){ tarjan(v,root); low[u] = min(low[u],low[v]); if(low[v]&gt;=dfn[u]&amp;&amp;u!=root){ cut[u] = true; //记录u节点为割点 } if(u==root) childtree++; } else low[u] = min(low[u],dfn[v]); } if(childtree&gt;=2&amp;&amp;u==root) cut[u] = true; // 根节点也为割点} 根据上述求法，我们还可以统计出删掉割点$u$之后连通块增加的个数 对于第一个搜索的点，连通块增加的个数是$childtree-1$。 对于其他点，连通块增加的个数是$u$被判为割点的次数 12345678910if(low[v]&gt;=dfn[u]&amp;&amp;u!=root) cut[u] = true;改为if(low[v]&gt;=dfn[u]&amp;&amp;u!=root) ++delta[u]; //删去u增加的连通图数量if(childtree&gt;=2&amp;&amp;u==root) cut[u] = true; 改为if(childtree&gt;=2&amp;&amp;u==root) delta[root] = childtree-1; 上例题 割点 嗅探器 桥在无向图中，删去一条边，使得图的连通块数量增加，则称这条边为桥。 在$tarjan$​的过程中，若$u$连接着$v$,$low[v]&gt;dfn[u]$,则连接$u、v$的边是桥，可画图理解。 123456789101112131415161718void Tarjan(int u, int fa){ dfn[u] = low[u] = ++cnt; //桥在无向图中是两条相同的边，所以边一般从0开始编号 for (int i = head[u]; i != -1; i = nxt[i]) { int v = edge[i]; if (dfn[v] == 0) { Tarjan(v, u); low[u] = min(low[u], low[v]); if (low[v] &gt; dfn[u]) bridge[i] = bridge[i ^ 1] = true;//i和i^1这两条边是同一条边，是桥 } else if (fa != v) low[u] = min(low[u], dfn[v]); }} 上例题 炸铁路 拓扑排序在图论中，拓扑排序(Topological Sorting)是一个有向无环图(DAG,Directed Acyclic Graph)的所有顶点的线性序列。且该序列必须满足以下两个条件： 每个顶点出现且仅出现一次。 若存在一条从顶点A到顶点B的路径，则在序列中顶点A在顶点B的前面出现。 有向无环图(DAG)才有拓扑排序，非DAG图没有拓扑排序一说。根据定义可知，一个DAG图的拓扑排序也许不止一个。 直接上题 摄像头 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;const int maxn = 510;int edge[maxn],head[maxn],nxt[maxn];int ind[maxn],outd[maxn];int has[maxn],a[maxn];int n,tot,ans;queue&lt;int&gt; q;void addEdge(int u,int v){ edge[++tot] = v; nxt[tot] = head[u]; head[u] = tot;}int main(){ ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { int m,y; cin&gt;&gt;a[i]&gt;&gt;m; has[a[i]] = 1; //该位置被监视 while(m--) { cin&gt;&gt;y; addEdge(a[i],y); outd[a[i]]++,ind[y]++; } } for(int i=1;i&lt;=n;i++) { if(ind[a[i]]==0) q.push(a[i]); } while(!q.empty()) { int u=q.front(); q.pop(); if(has[u]) ans++; //砸掉摄像头，该位置不被监视 for(int i=head[u];i;i=nxt[i]) { int v=edge[i]; ind[v]--; if(ind[v]==0&amp;&amp;has[v]==1) q.push(v); } } if(ans==n) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;n-ans&lt;&lt;endl; return 0;} 旅行计划","link":"/2021/10/27/%E5%9B%BE%E8%AE%BA-1/"},{"title":"图论(2)","text":"最短路最短路是非常常见的问题，有单源最短路和全源最短路，求解方法和各种应用也很多。来看一些常用、基本的最短路算法。 图的建立 用多个数组或一个结构体来直接存边。建图方便，操作效率低，在$Kruskal$算法中有应用。 邻接矩阵，$f[u][v]=w$表示$u$到$v$有一条权值为$w$的边。建图方便，遍历复杂度高，空间花费巨大，不适用于有重边的情况，一般用于稠密图，$Floyd$算法一般使用邻接矩阵。 vector存边。建图方便，可对边排序，操作效率高。 链式前向星。类似邻接表，理解后背模板即可，操作效率高，后文代码均使用此方式建图。 单源最短路单源最短路径指的是求从图上一个起点出发到其他所有点的最短路径。 以下默认一张图中$n$个点，$m$条边。 $Bellman-Ford$算法Bellman-Ford算法最核心的操作是松弛操作，其思想为：用当前节点的最短路去更新其邻接点的最短路。 容易想到，一条最短路上最多只有$n$个点和$n-1$​条边，因此我们只需要对每一条边尝试松弛$n-1$次，若存在最短路，则这些操作后一定找齐了所有的最短路，且所有边均不能再松弛操作；若仍能进行松弛操作，表示存在负环。 Bellman-Ford算法非常暴力，时间复杂度很高。显然，在对一条边进行松弛时，只有它的前驱节点已经进行过最短路的估计，即$dist[u]$不为$\\infty$时，边$(u,v)$才能被松弛。在Bellman-Ford算法中，有大量的边在遍历时不需要被松弛。 我们可以利用队列进行优化得到$SPFA$​算法。 $SPFA$算法对于Bellman-Ford，将所有更新过的点加入队列，每次取出一个点进行松弛，直到队列为空，这就是$spfa$​. 1234567891011121314151617181920212223242526void spfa(int s){ for(int i=1;i&lt;=n;i++) dist[i] = INF; //设置初始距离为无穷大，用来松弛 queue&lt;int&gt; q; dist[s] = 0; //到自身距离为0 q.push(s); flag[s] = true; //标记入队 while(!q.empty()) { int u = q.front(); q.pop(); flag[u] = false; //标记出队 for(int i=head[u];i;i=nxt[i]) { int v = edge[i],w = weight[i]; if(dist[v]&gt;dist[u]+w){ dist[v] = dist[u]+w; //松弛操作 if(!flag[v]){ q.push(v); flag[v] = true; //标记入队 } } } }} 但是即使使用队列优化过，$spfa$​时间复杂度依然很高，最坏情况下达到$O(|V|\\cdot |E|)$​.很容易被卡掉。 负环判定$spfa$的一个优点在于可以判别图中是否存在负环。判定方法是：记录每个点的入队次数，如果这个次数达到了总的节点数则说明图中存在负环。 注意是判入队次数而不是松弛次数，如果存在重边导致了多次松弛，会对松弛次数的判断产生影响，可能会被$hack$。 123456789if(dist[v]&gt;dist[u]+w){ dist[v] = dist[u] + w; //松弛操作 if(!flag[v]){ if(++cnt[v]&gt;=n) //判入队次数，当大于等于n时说明存在负环 printf(&quot;存在负环\\n&quot;); q.push(v); flag[v] = true; }} 但是这种方法可能会爆$int$，原因在于要让入队次数达到$n$，则遍历的总个数最大可达$n^2$. 考虑换一种思路，如果不存在负环，那么从某点出发到每个点的最短路应当是不存在环的。因此我们可以判断最短路径的路径边数是否小于$n$(即经过点数小于等于n，没有任何一个点重复走过)，来更高效地判断负环。 12345678910if(dist[v]&gt;dist[u]+w){ dist[v] = dist[u] + w; if(!flag[v]){ cnt[v] = cnt[u]+1; //v的最短路上经过点数比u多1 if(cnt[v]&gt;=n) printf(&quot;存在负环\\n&quot;); flag[v] = 1; q.push(v); }} 负环 $Dijkstra$算法$spfa$如此之慢，我们需要一种更快更稳定的最短路算法。 $dijkstra$​算法的思想是贪心+$bfs$​求最短路，它只适用于不含负边权的图。在稠密图中表现优秀。 我们将点分成两类，一类是已经确定最短路径的点，称为“白点”，另一类是未确定最短路径的点，称为“蓝点”。 $dijkstra$流程如下： 初始化$dist[s]==0$,其余节点的$dist$值为$\\infty$. 找到一个$dist$​最小的蓝点$u$​，将节点$u$​变成白点，即找到最短路。 遍历$u$的所有出边$(u,v,w)$，若$dist[v]&gt;dist[u]+w$,则$dist[v]=dist[u]+w$. 重复$2,3$两步，直到所有点变成白点。 这样做的时间复杂度是$O(n^2)$​​。 图解 另初始节点$s$为1，把$dist[s]$初始化为0，其余点初始化为$\\infty$. 第一轮循环找到$dist$最小的点$1$,将$1$变成白点，对所有与$1$相连的蓝点的$dist$进行松弛，使$dist[2]=2,dist[3]=4,dist[4]=7$ 第二轮循环找到$dist$最小的点$2$，将$2$变成白点，对所有与2相连的蓝点的$dist$​​进行松弛，使$dist[3]=3,dist[5]=4$ 第三轮循环找到$dist$最小的点是$3$，将3变成白点，对所有与3相连的蓝点进行松弛，使$dist[4]=4$ 接下来两轮循环分别将4、5设置为白点，算法结束，所有点最短路径找到。 为什么$dijkstra$​不能处理负边权图 我们来看下面这张图 2到3的边权为-4，显然从1到3的最短路径为-2(1-&gt;2&gt;3).但在循环开始时程序会找到当前$dist$最小的点3，并将其标记为白点。 这时$dist[3]=1$,然而1并不是起点到3的最短路径，且3已经被标记为白点，所以$dist[3]$不会再被修改。 我们在边权为负时得到了错误的答案。 $dijkstra$的堆优化观察流程，发现步骤2可以优化。我们用小根堆对$dist$数组进行维护，在$O(\\log n)$​的时间取出堆顶元素并删除，用$O(\\log n)$遍历每条边，总的时间复杂度为$O((n+m)\\log n)$. $dijkstra$​的正确性我们可以考虑反证法。假如点$u$在出队后优先队列中还有点$y$可以使$dist[u]$减小，那么$dist[y]$必然小于$dist[u]$.而根据优先队列的性质，$dist[u]$是堆中最小的元素，即$dist[u]\\leq dist[y]$,产生矛盾。因此可以保证$u$出队后$dist[u]$是最小的。 123456789101112131415161718192021222324252627282930313233struct Node{ int id; int val; Node(){} Node(int id,int val): id(id),val(val) {} bool operator &lt; (const Node s) const{ //重载小于号，使其为小根堆 return val&gt;s.val; }};priority_queue&lt;Node&gt; q;void dijkstra(int s){ for(int i=1;i&lt;=n;i++) dist[i] = INF; //设置初始距离为无穷大 dist[s] = 0; q.push(Node(s,dist[s])); while(!q.empty()) { Node now = q.top(); q.pop(); int u = now.id; if(vis[u]) continue; //如果已经找到最短路，跳过 vis[u] = true; for(int i=head[u];i;i=nxt[i]){ int v = edge[i],w=weight[i]; if(dist[v]&gt;dist[u]+w){ dist[v] = dist[u]+w; if(!vis[v]) q.push(Node(v,dist[v])); } } }} 上模板 $DAG$图最短路$DAG$图即有向无环图，可以直接对图进行拓扑排序，按照点的顺序一次进行松弛操作即可。 正确性拓扑排序后松弛的顺序即是最终结果中最短路边的顺序，每次松弛前边的起点都已经找到最短路，满足最优子结构。 时间复杂度线性 全源最短路全源最短路径指求图上任意两点之间的最短路径。 常见算法包括$Floyd$算法、$Johnson$算法。 $Floyd$​算法$floyd$算法是一种动态规划求解最短路的方法，其基本思想是：对于每个起点和终点，枚举中间点，进行状态转移。 转移方程为$d_{x,y}=min(d_{x,k}+d_{k,y}|1\\leq k \\leq n)$ 时间复杂度为$O(n^3)$ 1234for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]); $floyd$算法还可以判断图中两个点是否连通，在数据范围较小时非常好用。 上例题Cow Contest S $Johnson$算法$johnson$算法求任意两点间的最短路，是通过枚举起点，跑$n$次$dijkstra$算法解决，算法的时间复杂度为$O(nm\\log m)$，在稀疏图上比$floyd$算法更加优秀。 但是$dijkstra$算法不能正确求解带负权边的最短路问题，因此我们需要在原图上做预处理，确保所有的边权非负。 一种任意想到的方法是给所有边的边权同时加上一个正数$x$，从而让所有的边权非负。如果新图上起点到终点的最短路经过了$k$条边，则将最短路减去$kx$得到实际最短路。 但这种方法是错误的。因为如果原图上最短路边数较多，再每条边加上正数$x$后，新图可能存在一条边数更少的最短路，这时已经不是原来的最短路了。 $johnson$​算法通过另一种方法来给每条边重新标注边权。 我们建立一个超级源点（编号为$0$），从这个点向每一个点连一条权值为$0$的边。 首先可以用$spfa$​​求出源点到每个节点的最短路，记为$h_i$​。 假设原图中存在一条从$u$​到$v$​，边权为$w$​的边，我们将该边的边权重新设置为$w+h_u-h_v$​。 接下来以每个点为起点，跑$n$轮$dijkstra$算法即可求出新图任意两点间的最短路。 以$u$​为起点，$v$​为终点的最短路结果求出为$dist[v]$​​,实际在原图上为$dist[v]+h_v-h_u$​​。 正确性证明 在重新标记的图上，从$s$点到$t$点的一条路径$s-&gt;p_1-&gt;p_2-&gt;\\cdots -&gt;p_k-&gt;t$的长度表达式为： $(w(s,p_1)+h_s-h_{p_1})+(w(p_1,p_2)+h_{p_1}-h_{p_2})+\\cdots +(w(p_k,t)+h_{p_k}-h_t)$ 化简后得到： $w(s,p_1)+w(p_1,p_2)+\\cdots +w(p_k,t)+h_s-h_t$ 无论我们走哪一条路径，$h_s-h_t$的值不变的。这类似于两点间势能差的概念，只与两点位置有关。 为了方便，下面我们就把$d_i$称为$i$点的势能。 新图中的$s-&gt;t$的最短路长度表达式有两部分组成，前面的边权和为$s$到$t$的最短路，后面为两点的势能差。因为两点间的势能差为定值，因此原图上$s-&gt;t$的最短路与新图上$s-&gt;t$的最短路相对应。 至此我们证明了重新标注后图上最短路径仍是原图上的最短路径，接下来需要证明标注后所有边权非负，因为在非负边权上，$dijkstra$才能保证得出正确的结果。 根据三角形不等式，新图上任意一边$(u,v)$​满足：$h_v\\leq h_u+w(u,v)$。这条边重新标注之后的边权为$w’(u,v)=w(u,v)+h_u-h_v\\geq 0$。这样证明了标注后边权均非负。 至此我们证明了$johnson$算法的正确性。 上模板johnson全源最短路 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e5+10;inline int read(){ int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') { if (ch == '-') f = -1; ch = getchar(); } while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') { x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); ch = getchar(); } return x * f;}struct Node{ int id; int val; Node(){} Node(int id,int val): id(id),val(val) {} bool operator &lt; (const Node s) const{ return val&gt;s.val; }};ll head[maxn],nxt[maxn],edge[maxn],weight[maxn];ll dist[maxn];//距离ll d[maxn];ll cnt[maxn];bool vis[maxn];ll tot,n,m;void addEdge(int u,int v,int w){ edge[++tot] = v; weight[tot] = w; nxt[tot] = head[u]; head[u] = tot;}bool spfa(int s){ queue&lt;int&gt; q; for(int i=1;i&lt;=n;i++) d[i] = 63; d[s] = 0; q.push(s); vis[s] = 1; while(!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for(int i=head[u];i;i=nxt[i]) { int v = edge[i],w=weight[i]; if(d[v]-d[u]&gt;w){ d[v] = d[u]+w; if(!vis[v]){ cnt[v] = cnt[u]+1; if(cnt[v]&gt;=n+1) return false; //判负环 q.push(v); vis[v] = 1; } } } } return true;}void dijkstra(int s){ priority_queue&lt;Node&gt; q; for(int i=1;i&lt;=n;i++){ dist[i] = INF; //设置初始距离为无穷大 vis[i] = 0; } dist[s] = 0; q.push(Node(s,dist[s])); while(!q.empty()) { Node now = q.top(); q.pop(); int u = now.id; if(vis[u]) continue; //如果已经找到最短路，跳过 vis[u] = true; for(int i=head[u];i;i=nxt[i]){ int v = edge[i],w=weight[i]; if(dist[v]&gt;dist[u]+w){ dist[v] = dist[u]+w; if(!vis[v]) q.push(Node(v,dist[v])); } } }}int main(){ n =read(),m=read(); while(m--) { int u,v,w; u = read(),v=read(),w=read(); addEdge(u,v,w); } for(int i=1;i&lt;=n;i++) addEdge(0,i,0); //建超级源点 if(!spfa(0)) { cout&lt;&lt;-1&lt;&lt;endl; //存在负环直接退出 return 0; } for(int u=1;u&lt;=n;u++) for(int i=head[u];i;i=nxt[i]) weight[i] += d[u]-d[edge[i]]; for(int i=1;i&lt;=n;i++) { dijkstra(i); ll ans=0; for(int j=1;j&lt;=n;j++) { if(dist[j]==INF) ans += j*1e9; //注意相乘结果需要是long long型（卡这里wa了好久 else ans += (ll)j*(dist[j]+d[j]-d[i]); } printf(&quot;%lld\\n&quot;,ans); } return 0;} 差分约束系统还不会 $K$短路还不会 同余最短路还不会","link":"/2021/10/28/%E5%9B%BE%E8%AE%BA-2/"},{"title":"搜索题解","text":"本篇文章对一些搜索题目进行摘录。 赵子龙七进七出原题链接 题目描述 分析每隔三条边才能算作跳一步过去，一开始的想法是重新建图，利用最短路求解。但是重新建图并不方便，由于问最少前进步数，所以可以直接$bfs$.设置数组$mark[s][step]$,表示到点$s$时是隔了几步，对$s$的邻接点进行遍历，$step$变成$(step+1)\\pmod 3$.最后判断是否走到了终点，如果走到，步数除以$3$即可。 代码展开查看 >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; PI;const int maxn = 1e5+10;const ll mod = 1e9+7;inline int read(){ int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') { if (ch == '-') f = -1; ch = getchar(); } while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') { x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); ch = getchar(); } return x * f;}int n,m;int s,t;vector&lt;int&gt;g[maxn];int mark[maxn][3]; //第走到这个点是哪步int dp[maxn][3]; //走了多少步void bfs(){ queue&lt;PI&gt; q; q.push(PI(s,0)); mark[s][0] = 1; //第0步走到的点才是能跳到的点 dp[s][0] = 0; //初始步数为0 while(!q.empty()) { PI now = q.front(); q.pop(); int u = now.first,step = now.second; for(auto v:g[u]) { int ss = (step+1)%3; if(mark[v][ss]==0) { mark[v][ss] = 1; //设置标记 dp[v][ss] = dp[u][step]+1; //步数加1 q.push(PI(v,ss)); } } }}int main(){ cin&gt;&gt;n&gt;&gt;m; while(m--) { int u,v; u = read(),v = read(); g[u].push_back(v); } cin&gt;&gt;s&gt;&gt;t; bfs(); if(mark[t][0]==0) { cout&lt;&lt;-1&lt;&lt;endl; return 0; } cout&lt;&lt;dp[t][0]/3; //第0步走到，步数除以三即可 return 0;}","link":"/2021/11/08/%E6%90%9C%E7%B4%A2%E9%A2%98%E8%A7%A3/"},{"title":"子数组和为k问题","text":"关于各种子数组的和小于(大于)或等于k的最长最短子数组或者求有多少个这样的子数组问题,可以分成两类。 当数组全是正数的时候，用双指针算法 当数组存在负数的时候，用前缀和+哈希表优化，也可使用单调队列优化 求一个数组中和为k的子数组的个数如果直接暴力做，复杂度为$O(n^2)$​​​​,不能通过。此题考虑前缀和+哈希表优化。我们定义$pre[i]$​​​为$[0,i]$​里所有的数的和，则$pre[i]$由$pre[i-1] + nums[i]$​​​​得来，即$$pre[i] = pre[i-1]+nums[i]$$那么找到一个子数组$[j…i]$和为$k$​这个条件可以转化成$$pre[j-1]==pre[i]-k$$于是问题就变为考虑以$i$结尾的和为$k$的连续子数组时，只要统计有多少个前缀和为$pre[i]-k$的$pre[j]$​​​​即可。 我们建立哈希表$mp$​，以和为键值，到当前位置出现次数为对应值，记录$pre[i]$出现的次数，从左往右边更新边计算答案，那么以$i$为结尾的答案$mp[pre[i]-k]$即可在$O(1)$时间内得到。最后答案即为所有$mp[pre[i]-k]$​​的和。 需要注意的是，因为我们从左往右边更新边计算时保证了$mp[pre[i]-k]$​​里记录的$pre[j]$​​的下标范围是$0 \\leq j \\leq i$​​.同时，由于$pre[i]$​​只与前一项$pre[j-1]$​有关，因此我们不必建前缀和数组，直接使用$pre$​​变量来记录和即可。 123456789101112int subarraySum(vector&lt;int&gt;&amp; nums,int k) { unordered_map&lt;int,int&gt; mp; int count = 0,pre = 0; mp[0] = 1; //当前前缀和就为k时是存在一个子数组的 for(auto x:nums){ pre += x; if(mp.find(pre-k) != mp.end()) count += mp[pre-k]; mp[pre]++; } return count;} 求一个数组中和为数组长度的子数组个数这个题是在训练群中听学长的面试官同事提的。咋一看比较没有思路，但是把数组每个元素减1，就变成了子数组和为0，和上题一样。 求一个数组中和为k的最长子数组长度仍然是前缀和+哈希表方式。这时哈希表以和为键，以右端点为对应值。当存在$mp[pre[i]-k]$​​时，也就是找到了一段和为$k$的子数组，这时比较$maxlen$和$i-mp[pre-k]$​​​更新答案即可。 12345678910111213int maxlenOfArray(vector&lt;int&gt;&amp; nums,int k) { unordered_map&lt;int,int&gt; mp; mp[0] = -1; int maxlen = 0,pre = 0; for(int i = 0;i &lt; nums.size();i++) { pre += nums[i]; if(mp.find(pre-k)) maxlen = maxlen&gt;i-mp[pre-k]?maxlen:i-mp[pre-k]; if(mp.find(pre) == mp.end()) mp[pre] = i//总是在第一次遇到这个和时插入map，使这个值尽可能早 } return maxlen;} 求一个01串中最长01数量相等的子串此题将$0$​看做$-1$，则是找和为$0$​​的最长子串长度。 2021 CCPC Command Sequence题意一个机器人能上下左右移动，分别对应字符$UDLR$​.给定一个机器人移动序列字符串，问有多少个子串可以使其按照子串的顺序来走能回到原点。 分析此题我们直接将每个字符看成一个数字，且上下互为相反数，左右互为相反数，那么就是找到这个数字序列有多少个和为$0$​​的子序列。依旧是前缀和+哈希表结构。需要注意的是，由于一个$2$​​可以由两个$-1$​​抵消，所以上下和左右代表的数字不能太接近。这里字符串长度最大为$10^5$​​，所以我们可以让$U$​和$D$​代表$1$​和$-1$​，让$L$​和$R$​代表$100000$​和$-100000$​​​​​​​​。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;unordered_map&gt;using namespace std;typedef long long ll;const int maxn = 1e5 + 10;int t, n;ll a[maxn];char s[maxn];int main(){ cin &gt;&gt; t; while (t--) { cin &gt;&gt; n; cin &gt;&gt; s + 1; for (int i = 1; i &lt;= n; i++) { if (s[i] == 'U') a[i] = 1; if (s[i] == 'D') a[i] = -1; if (s[i] == 'L') a[i] = 100000; if (s[i] == 'R') a[i] = -100000; } unordered_map&lt;ll, int&gt; mp; mp[0] = 1; ll pre = 0, count = 0; for (int i = 1; i &lt;= n; i++) { pre += a[i]; if (mp.find(pre) != mp.end()) count += mp[pre]; mp[pre]++; } cout &lt;&lt; count &lt;&lt; endl; } return 0;} 数学？题目描述给你一个长度为$n$​的数组$a$​和一个正整数$k$​，问$a$​有多少个和$\\geq k$​的​​连续子序列。 分析如果连续子序列$[l,r]$的和已经$\\geq k$,那么从$l$到$r+1$、从$l$到$r+2$​、$\\cdots$、从$l$到$n$的和都$\\geq k$。这样的子序列有$n-r+1$个。因此，我们可以枚举$l$从$1$到$n$，对于每一个$l$，找到最小的$r$使得$\\sum[l,r]\\geq k$,那么从$l$开始的符合条件的子序列就有$n-r+1$个。 对于给定的左边界$l$，如何快速找到最小满足条件的$r$,可以使用滑动窗口的办法。 我们得到上一个$l$的最小$r$之后，记录下这个最小的$r$和$[l,r]$的和。当$l$变成$l+1$时，让上次的和减去$a[l]$,得到的是$[l+1,r]$的和。 如果这个和仍大于等于$k$，那么$r$仍然是最小的$r$，更新答案即可。 否则$r$向右移动变成$r+1$，和也加上$a[r+1]$，直到和又大于等于$k$，此时的$r$又是最小的$r$。 上述过程中，一旦$r$​超过数组范围就结束了。 $r$从$1$移到了$n$，时间复杂度为$O(n)$。 代码123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;typedef long long ll;ll a[100010];int main() { int n; ll k; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) { scanf(&quot;%lld&quot;, &amp;a[i]); } ll ans = 0; // 答案 ll left = 0, right = 0; // l和r初始值都是0 ll sum = a[0]; // sum代表[left, right]的和 while (right &lt; n) { if (sum &gt;= k) { // sum[l, r] &gt;= k ans += n - right; sum -= a[left++]; // 枚举下一个l（l++），相应地sum也要减去不在范围内的a[l] } else { // sum[l, r] &lt; k，还没找到最小的r sum += a[++right]; // r右移并累加入总和 } } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2021/10/21/%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E4%B8%BAk%E9%97%AE%E9%A2%98/"},{"title":"线段树与树状数组","text":"线段树和树状数组是很常用的数据结构，用来处理区间问题，包括区间的修改和查询。 线段树线段树，顾名思义，是将区间分成一段一段来进行区间操作。对于每个子节点，都表示整个序列的一段子区间；对于叶子节点而言，都表示序列中单个元素信息；子节点不断向自己的父亲节点传递信息，而父节点存储的信息是它每一个子节点信息的整合。 线段树可以维护支持结合律的数据，比如加和，乘法，最大/最小值。 如何进行分段？ 考虑将区间$[l,r]$分成两半$[l,mid]、[mid+1,r]$​,相当于将区间对半分，对于每个区间都这样分段，最终段数为$O(n\\log n)$. 当我们对区间$[l,r]$进行操作时，从最大的区间开始，从此去找对应操作的区间。 $[l,r]$包含在当前节点的左区间内，接着往左区间走 $[l,r]$​包含在当前节点的右区间内，接着往右区间走 $[l,r]$​跨过当前节点区间的中点，左边操作$[l,mid]$​​,右边操作$[mid+1,r]$​ 如此反复，直到找到的区间与操作区间一致，就进行操作。 线段树大致图像如下： 当涉及到区间的修改，如加减、乘除时，我们可以在找到的区间上打上懒标记($lazy tag$​),这样不用每次往下遍历整棵线段树。在进行修改和查询时要注意懒标记的下传，还要向上更新节点维护的值。 线段树1 懒标记的优先级当区间的修改包括了加和乘时，需要设置两个标记，$add$加标记、$mul$乘标记。而这时候需要注意优先级问题。 先进行乘法后进行加法。 如果我维护的值是$a$，我的懒标记有$+b$​和$\\times c$，可以发现$(a+b)\\times c \\neq a\\times c+b$. 而在记录懒标记时，加法和乘法两种标记放到一起，需要确定一个优先级。 我们分析一下两种顺序： 先加后乘：$(a+b)\\times c = a\\times c+b\\times c$ 先乘后加：$a\\times c+b$ 上面先加后乘的式子相当于下面的式子，在加法上面多乘了一个$c$ 所以，只要是先加后乘的式子，只要在$b$上$\\times c$就可以转化为先乘后加的式子 具体操作是在添加乘法标记的时候，先将加法标记$\\times c$即可 懒标记下传推导在传递懒标记$pushdown$时 假设当前节点是$o$,$add[o]$是当前节点的加法标记，$mul[o]$是当前节点的乘法标记，$sum[o]$是当前节点维护的和，$ls$是左儿子的编号，$rs$是右儿子的编号。这里当前节点的值已经维护好，儿子还没维护好。 以左儿子为例，根据先乘后加的顺序，给左儿子乘上自己的乘法标记，再加上自己的加法标记。 $$sum[ls] = sum[ls]\\times mul[o]+add[o]\\times (r-l+1)$$ 这样，左儿子的$sum$值就维护好了。那么如果儿子有懒标记呢？ 如果儿子有懒标记，它的懒标记要维护一个值$s$，它维护后的值$s’$应该是 $$s’ = s\\times mul[ls]+add[ls]$$ 现在又要给它加上父节点$o$的懒标记，那么维护后的值应该是$$\\begin{equation}\\begin{split}s’’&amp;=s’\\times mul[o] + add[o] \\ &amp;=(s\\times mul[ls]+add[ls])\\times mul[o]+add[o] \\ &amp;=s\\times mul[ls]\\times mul[o]+add[ls]\\times mul[o]+add[o]\\end{split}\\end{equation}$$如果$mul[ls]’,add[ls]’$是维护后的懒标记，我们就知道了懒标记应该怎么维护 $$mul[ls]’ = mul[ls]\\times mul[o]$$ $$add[ls]’=add[ls]\\times mul[o]+add[o]$$ 在维护懒标记时，乘法标记乘以父节点的乘标记，加法标记先乘以父节点的乘标记，再加上父节点的加标记即可。 线段树2 模板展开查看代码 >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e5 + 10;inline ll read(){ ll x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') { if (ch == '-') f = -1; ch = getchar(); } while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') { x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); ch = getchar(); } return x * f;}struct node{ int l, r; ll sum, add, mul = 1; //该点维护的和，加标记，乘标记初始为1} tree[maxn &lt;&lt; 2];ll a[maxn];ll n, m, p;inline int ls(int pos) { return pos &lt;&lt; 1; }inline int rs(int pos) { return pos &lt;&lt; 1 | 1; }//向上更新节点维护的和void pushup(int pos){ tree[pos].sum = (tree[ls(pos)].sum + tree[rs(pos)].sum) % p;}void build(int pos, int l, int r) //当前节点，操作区间{ tree[pos].l = l, tree[pos].r = r; if (l == r) { tree[pos].sum = a[l] % p; return; } int mid = l + r &gt;&gt; 1; build(ls(pos), l, mid); build(rs(pos), mid + 1, r); pushup(pos);}//向下传递懒标记void pushdown(int pos){ if (tree[pos].mul != 1) { //更新两个标记与节点维护的和,直接乘 (tree[ls(pos)].mul *= tree[pos].mul) %= p; (tree[rs(pos)].mul *= tree[pos].mul) %= p; (tree[ls(pos)].add *= tree[pos].mul) %= p; (tree[rs(pos)].add *= tree[pos].mul) %= p; (tree[ls(pos)].sum *= tree[pos].mul) %= p; (tree[rs(pos)].sum *= tree[pos].mul) %= p; //已经传递，修改为1 tree[pos].mul = 1; } if (tree[pos].add) { (tree[ls(pos)].add += tree[pos].add) % p; (tree[rs(pos)].add += tree[pos].add) % p; //左子树的sum值加上 节点数*懒标记 (tree[ls(pos)].sum += (tree[ls(pos)].r - tree[ls(pos)].l + 1) * tree[pos].add % p) %= p; //右子树的sum值加上 节点数*懒标记 (tree[rs(pos)].sum += (tree[rs(pos)].r - tree[rs(pos)].l + 1) * tree[pos].add % p) %= p; //已经传递，修改为0 tree[pos].add = 0; }}//加法更新void updateAdd(int pos,int l,int r,int k){ if(tree[pos].l==l&amp;&amp;tree[pos].r==r){ //更新该节点维护的和 (tree[pos].sum += (r-l+1) * k % p) %= p; //更新该节点懒标记 (tree[pos].add += k) %= p; return; } //注意要先pushdown!!! pushdown(pos); int mid = tree[pos].l+tree[pos].r&gt;&gt;1; //只在左儿子节点更新 if(r&lt;=mid) updateAdd(ls(pos),l,r,k); //只在右儿子节点更新 else if(l&gt;mid) updateAdd(rs(pos),l,r,k); //在左右儿子节点更新 else updateAdd(ls(pos),l,mid,k),updateAdd(rs(pos),mid+1,r,k); //最后pushup!!! pushup(pos);}//乘法更新void updateMul(int pos,int l,int r,int k){ if(tree[pos].l==l&amp;&amp;tree[pos].r==r){ //更新该节点维护的和 (tree[pos].sum *= k) %= p; //更新该节点懒标记 (tree[pos].add *= k) %= p; (tree[pos].mul *= k) %= p; return; } //注意要先pushdown!!! pushdown(pos); int mid = tree[pos].l+tree[pos].r&gt;&gt;1; //只在左儿子节点更新 if(r&lt;=mid) updateMul(ls(pos),l,r,k); //只在右儿子节点更新 else if(l&gt;mid) updateMul(rs(pos),l,r,k); //在左右儿子节点更新 else updateMul(ls(pos),l,mid,k),updateMul(rs(pos),mid+1,r,k); //最后pushup!!! pushup(pos);}ll query(int pos,int l,int r){ if(tree[pos].l==l&amp;&amp;tree[pos].r==r){ return tree[pos].sum; } //注意先pushdown!!! pushdown(pos); int mid = tree[pos].l+tree[pos].r&gt;&gt;1; //只在左儿子节点查询 if(r&lt;=mid) return query(ls(pos),l,r); //只在右儿子节点查询 else if(l&gt;mid) return query(rs(pos),l,r); //在左右儿子节点查询 else return (query(ls(pos),l,mid)+query(rs(pos),mid+1,r))%p;}int main(){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;p; for(int i=1;i&lt;=n;i++) a[i] = read(); build(1,1,n); while(m--) { int opt; ll x,y,k; opt = read(),x = read(),y = read(); if(opt==1){ k = read(); updateMul(1,x,y,k); } else if(opt==2){ k = read(); updateAdd(1,x,y,k); } else if(opt==3){ printf(&quot;%lld\\n&quot;,query(1,x,y)); } } return 0;} 树状数组单点修改，区间查询树状数组用于维护前缀和，可以单点修改。 大致图像如下 每个节点维护值的长度是该节点二进制最低位1代表的值。 树状数组中$lowbit$​函数是得到一个数的最低位1代表的值，比如$lowbit(5)=1,lowbit(4)=4$. 如果改变$x$位置的值，就加上该位置的$lowbit$，一直加到$n$，就维护了树状数组。 查询时反过来，从$x$位置开始，减去当前位置的$lowbit$，一直减到$1$，就得到$x$位置的前缀和。 树状数组1 12345678910111213141516171819202122232425262728293031323334353637383940414243int a[maxn],n,m;ll tree[maxn]; //树状数组int lowbit(int x) { return x &amp; (-x); }void add(int x,int k){ for(int i=x;i&lt;=n;i+=lowbit(i)) tree[i] += k;}ll query(int x){ ll ans = 0; for(int i=x;i;i-=lowbit(i)) ans += tree[i]; return ans;}int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) a[i] = read(); for(int i=1;i&lt;=n;i++) add(i,a[i]); int opt,x,y,k; while(m--) { opt = read(); if(opt==1) { x = read(),k=read(); add(x,k); } else if(opt == 2) { x = read(),y = read(); printf(&quot;%d\\n&quot;,query(y)-query(x-1)); } } return 0;} 区间修改，单点查询区间修改用到差分数组的知识，若原数组为$a$,其差分数组为$b$，则$a[i] = b[1]+b[2]+\\cdots +b[i]$. 若要修改原数组$[l,r]$区间上的值，比如都加$2$，只需要在差分数组中$b[l]$位置$+2$，$b[r+1]$位置$-2$即可。 由于树状数组维护前缀和，所以用树状数组维护原数组，用差分数组建树状数组，查询时直接查询即可。 树状数组2 1234567891011121314151617181920212223242526272829303132333435363738394041424344int a[maxn],n,m;ll tree[maxn]; //树状数组int lowbit(int x) { return x &amp; (-x); }void add(int x,int k){ for(int i=x;i&lt;=n;i+=lowbit(i)) tree[i] += k;}ll query(int x){ ll ans = 0; for(int i=x;i;i-=lowbit(i)) ans += tree[i]; return ans;}int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) a[i] = read(); for(int i=1;i&lt;=n;i++) add(i,a[i]-a[i-1]); int opt,x,y,k; while(m--) { opt = read(); if(opt==1) { x = read(),y = read(),k=read(); add(x,k); add(y+1,-k); } else if(opt == 2) { x = read(); printf(&quot;%d\\n&quot;,query(x)); } } return 0;} 总结虽说只是模板，但是线段树这两题还是写了很久，代码量巨大。不过也比之前理解地更清楚了，虽说线段树是很有用的工具，但对于我来讲估计用上它的概率不大，用上的也写不出(太菜了)。","link":"/2021/11/03/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8E%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"title":"JDBC技术","text":"本篇文章记录学习JDBC的内容，虽然这部分最后都被封装起来，但是了解如何建立连接，执行sql语句，关闭连接很有必要。 $JDBC$​概述 $JDBC$​(java Database Connectivity)是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口（一组API），定义了用来访问数据库的标准java类库(java.sql,javax.sql)使用这些类库可以以一种标准的方法方便地访问数据库资源。 JDBC为访问不同的数据库提供了一种统一的途径。 有了JDBC之后，java程序访问数据库的方式如图 JDBC程序编写步骤 获取数据库连接$Driver$接口 java.sql.Driver接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库 厂商提供不同的实现。 在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用 这些Driver实现。 mysql的驱动：com.mysql.cj.jdbc.Driver(mysql8.0之后) 加载与注册驱动 加载驱动：：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;) 注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序 使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动 通常不显式调用DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口 的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法 来注册自身的一个实例。下图是MySQL的Driver实现类的源码： 12345678// Register ourselves with the DriverManagerstatic { try { java.sql.DriverManager.registerDriver(new Driver()); } catch (SQLException E) { throw new RuntimeException(&quot;Can't register driver!&quot;); }} $URL$ JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到 数据库的连接。 JDBC URL的标准由三部分组成，各部分间用冒号分隔。 jdbc:子协议:子名称 协议：JDBC URL中的协议总是jdbc 子协议：子协议用于标识一个数据库驱动程序 子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了定位数据库 提供足够的信息。包含主机名(对应服务端的ip地址)，端口号，数据库名 MySQL的连接URL编写方式： jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&amp;参数=值 jdbc:mysql://localhost:3306/test?useSSL=false&amp;serverTimezone=UTC 连接方式1234567891011121314151617181920212223242526public static Connection getConnection(){ Connection conn = null; Properties pros = new Properties(); InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); try { pros.load(is); } catch (IOException e) { e.printStackTrace(); } String url = pros.getProperty(&quot;url&quot;); String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); String driverName = pros.getProperty(&quot;driverName&quot;); try { /** * 加载驱动，这一句也可以删除，在META-INF下的services的java.sql.Driver定义了驱动 * 但是不建议删除 */ Class.forName(driverName); //获取连接 conn = DriverManager.getConnection(url,user,password); } catch (Exception e) { e.printStackTrace(); } return conn;} 配置文件properties 1234user=rootpassword=123456url=jdbc:mysql://localhost:3306/test?useSSL=false&amp;serverTimezone=UTCdriverName=com.mysql.cj.jdbc.Driver CRUD操作操作和访问数据库 数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连 接就是一个Socket连接。 在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式： Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。 CallableStatement：用于执行 SQL 存储过程 使用$Statement$​操作数据表的弊端 存在拼串操作，繁琐 存在SQL注入问题 SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段 或命令（如select * from tablename where username=''or true or'' and password=''),在输入or true or后sql语句结构发生了变化，变为了或的逻辑关系，不管用户名和密码是否匹配该式的返回值永远为true。 $PreparedStatement$​的使用 Preparement样式为select*from tablename where username=? and password=? SQL语句会在得到用户的输入之前先用数据库进行预编译，这样的话不管用户输入什么用户名和密码的判断始终都是并的逻辑关系，防止了SQL注入 可以通过调用 Connection 对象的 preparedStatement(String sql) 方法获取 PreparedStatement 对象 PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句 preparedStatement使代码的可读性和可维护性提高。 PreparedStatement 能最大可能提高性能： DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的 编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参 数直接传入编译过的语句执行代码中就会得到执行。 在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意 义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样每执行一次都要对传入的语句编译一次。 通用的增删改查操作更新操作（增、删、改）123456789101112131415//统一的增删改操作（考虑事务）public static void update(Connection conn,String sql,Object ...args){ PreparedStatement ps = null; try { ps = conn.prepareStatement(sql); for(int i=0;i&lt;args.length;i++){ ps.setObject(i+1,args[i]); } ps.executeUpdate(); } catch (SQLException e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(null,ps); }} 查询操作1234567891011121314151617181920212223242526272829public static &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql,Object ...args){ PreparedStatement ps = null; ResultSet resultSet = null; try { ps = conn.prepareStatement(sql); for(int i=0;i&lt;args.length;i++){ ps.setObject(i+1,args[i]); } resultSet = ps.executeQuery(); ResultSetMetaData rsmd = resultSet.getMetaData(); int columnCount = rsmd.getColumnCount(); if(resultSet.next()){ T t = clazz.newInstance(); for(int i=1;i&lt;=columnCount;i++){ String columnLabel = rsmd.getColumnLabel(i); Object value = resultSet.getObject(columnLabel); Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t,value); } return t; } } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(null,ps,resultSet); } return null;} 资源的释放 释放ResultSet, Statement,Connection。 数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将 导致系统宕机。Connection的使用原则是尽量晚创建，尽量早的释放。 操作$Blob$类型字段 MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。 插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。 MySQL的四种BLOB类型 类型 最大大小（单位：字节） TinyBlob 255 Blob 65K MediumBlob 16M LongBlob 4G 在mysql的安装目录下，可以在my.ini文件加上如下的配置参数： max_allowed_packet=16M，并重启数据库 插入$Blob$类型123FileInputStream fis = new FileInputStream(&quot;kele.jpg&quot;);ps.setBlob(4, fis);ps.executeUpdate(); 读取$Blob$类型12345678Blob photo = resultSet.getBlob(&quot;photo&quot;);is = photo.getBinaryStream(); //得到输入流fos = new FileOutputStream(&quot;mei.jpg&quot;);byte[] cbuf = new byte[1024];int len = 0;while ((len = is.read(cbuf)) != -1) { fos.write(cbuf, 0, len);} 数据库事务$JDBC$处理事务 事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。 事务处理：保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方 式。当在一个事务中执行多个操作时，要么所有的事务都被提交(commit)，那么这些修改就永久地保存下来； 要么数据库管理系统将放弃所作的所有修改，整个事务回滚(rollback)到最初状态。 数据一旦提交，就不可回滚。 数据什么时候意味着提交？ 当一个连接对象被创建时，默认情况下是自动提交事务：每次执行一个 SQL 语句时，如果执行成功，就会 向数据库自动提交，而不能回滚。 关闭数据库连接，数据就会自动的提交。如果多个操作，每个操作使用的是自己单独的连接，则无法保证 事务。即同一个事务的多个操作必须在同一个连接下。 JDBC程序中为了让多个 SQL 语句作为一个事务执行： 调用 Connection 对象的 setAutoCommit(false); 以取消自动提交事务。 在所有的 SQL 语句都成功执行后，调用 commit(); 方法提交事务。 在出现异常时，调用rollback方法，回滚事务。 $MySql$中设置隔离级别设置连接隔离级别123456//获取当前连接的隔离级别System.out.println(conn.getTransactionIsolation());//设置当前连接的隔离级别conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);//取消自动提交conn.setAutoCommit(false); 数据库连接池 JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器 (Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现，常用连接池： **C3P0 **是一个开源组织提供的一个数据库连接池，速度相对较慢，稳定性还可以。hibernate官方推荐使用 DBCP 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。速度相对c3p0较快，但因 自身存在BUG，Hibernate3已不再提供支持。 Druid 是阿里提供的数据库连接池，是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池。 DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接 池。 DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速 度。 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个 数据源即可。 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数 据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。 $Druid$数据库连接池123456789101112131415161718192021private static DataSource dataSource = null;static{ try { Properties pros = new Properties(); InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;druid.properties&quot;); pros.load(is); //静态代码块中，只创建一个连接池 dataSource = DruidDataSourceFactory.createDataSource(pros); } catch (Exception e) { e.printStackTrace(); }}public static Connection getConnectionOfDrud(){ Connection conn = null; try { conn = dataSource.getConnection(); } catch (SQLException e) { e.printStackTrace(); } return conn;}druid.properties配置文件 Apache-DBUtils实现CRUD操作主要API的使用DbUtils DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法 如下： public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情 况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。 public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做 了判断 QueryRunner类 该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少 编码量。 QueryRunner类的主要方法： 更新：public int update(Connection conn, String sql, Object… params) throws SQLException:用来执行 一个更新（插入、更新或删除）操作。 查询：public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句 的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。 ResultSetHandler接口及实现类 该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。 ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet rs)。 接口的主要实现类： BeanHandler：将结果集中的第一行数据封装到一个对应的JavaBean实例中。 BeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。 MapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。 MapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List。 ScalarHandler：查询单个值对象(查询类似于最大的，最小的，平均的，总和，个数相关的数据) 在使用这些接口实现类时一定要给JavaBean添加setter方法，因为其重写的hand方法内部会调用赋值。 crud测试1234567891011121314151617//BeanHandler是ResultHandler的一个实现类，用于封装表中的一条记录。@Testpublic void testQuery1(){ QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnectionOfDrud(); String sql = &quot;select name,email,birth from customers where id=?&quot;; BeanHandler&lt;Customer&gt; handler = new BeanHandler&lt;&gt;(Customer.class); try { Customer customer = runner.query(conn, sql, handler, 28); System.out.println(customer); } catch (SQLException e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn,null); }}//BeanListHandler同理，返回的就是一个List 123456789101112131415161718/** * ScalarHandler:ResultSetHandler的一个实现类，返回特殊的值，如聚集函数 */@Testpublic void testQuery5(){ QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnectionOfDrud(); String sql = &quot;select max(birth) from customers&quot;; ScalarHandler handler = new ScalarHandler(); try { Date date = (Date) runner.query(conn, sql, handler); System.out.println(date); } catch (SQLException e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn,null); }} 自定义ResultSetHandler实现类如果不想使用自带的实现类，还可以自己实现ResultSetHandler类，只需重写handle方法处理结果集即可 1234567891011121314ResultSetHandler&lt;User&gt; handler = new ResultSetHandler&lt;User&gt;() { @Override public User handle(ResultSet resultSet) throws SQLException { if(resultSet.next()) { int id = resultSet.getInt(&quot;id&quot;); String username = resultSet.getString(&quot;username&quot;); String password = resultSet.getString(&quot;password&quot;); String email = resultSet.getString(&quot;email&quot;); User user = new User(id, username, password, email); return user; } return null; }};","link":"/2021/12/19/JDBC%E6%8A%80%E6%9C%AF/"},{"title":"Servlet学习","text":"本篇文章记录学习Servlet技术的内容。 什么是Servlet Servlet是JavaEE的一个接口，是JavaWeb的三大组件之一。三大组件分别是：Servlet、Filter过滤器、Listener监听器。 处理请求和发送响应的过程是由Servlet程序来完成的，并且Servlet是为了解决实现动态页面而衍生的东西。 Servlet是运行在服务器上的一个java程序，它可以接收客户端发送过来的请求，并发送响应数据给客户端。 Tomcat和Servlet的关系 Tomcat是Web应用服务器，是一个Servlet/JSP容器。Tomcat作为Servlet容器，负责处理客户端发送的请求，将请求传给Servlet，并将Servlet的响应传回给客户端。 从http协议中的请求和响应可以知道，浏览器发出的请求是一个请求文本，浏览器接收到的也是一个响应文本。 从上图可以看出是如何请求和响应的。 ①：Tomcat接收客户端的http请求文本并解析，然后封装成HttpServletRequest类型的request对象，所有的http头数据都可以通过request对象调用对应方法查到。 ②：Tomcat同时会将响应的信息封装成HttpServletResponse类型的response对象，通过设置response的属性可以控制输出到浏览器中的内容，然后将response交给Tomcat，Tomcat会将其变成响应文本的格式发送给浏览器。 Java Servlet API是Servlet容器(Tomcat)和Servlet之间的接口，它定义了Servlet的各种方法，还定义了Tomcat传送给Servlet的对象类，其中最重要的是ServletRequest和ServletResponse。在编写Servlet程序时，需要实现Servlet接口，实现里面的方法。 实现Servlet 编写一个类去实现Servlet接口 实现service方法，处理请求，并响应数据。 在web.xml中配置servlet程序的访问地址。需要让浏览器知道发出的请求到达哪个servlet，也就是让tomcat将封装好的request找到对应的servlet让其使用。 实现的servlet类 1234567public class HelloServlet implements Servlet{ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(&quot;HelloServlet被访问了&quot;); } //其它实现的方法省略} web.xml中需要配置以下四个信息。 12345678910111213141516&lt;servlet&gt; &lt;!--servlet-name给程序起一个别名--&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!--servlet的全类名--&gt; &lt;servlet-class&gt;servlet.HelloServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!--servlet-mapping标签给servlet程序配置访问地址--&gt;&lt;servlet-mapping&gt; &lt;!--告诉服务器，当前配置的地址给那个servlet程序使用，和上面的别名一致--&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!--配置访问地址 / 斜杠表示地址为：http://ip:port/工程路径 /hello 表示地址为：http://ip:port/工程路径/hello 这个地址就表示访问到HelloServlet这个类了--&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; url地址到Servlet程序的访问 Servlet的生命周期 执行Servlet构造器方法 执行init初始化方法 前两步是在第一次访问时创建Servlet程序时调用。 3.执行service方法（这一步每次访问都会调用）。 4.执行destroy销毁方法。（在web工程停止时调用）。 通过继承HttpServlet实现Servlet程序一般不会直接实现Servlet类实现Servlet程序，而是去继承HttpServlet类。在HttpServlet继承类中，只需要根据自己的需要去重写doGet和doPost方法既可。 查看HttpServlet类的继承结构，发现它继承于GenericServlet类。而GenericServlet类实现了Servlet类，对很多方法做了空实现。并且持有一个ServletConfig类的引用，对ServletConfig的使用定义了一些方法。 Servlet接口内容 可以看到，接口内有Servlet生命周期的三个关键方法，init、service、destroy，还有一个重要的getServletConfig方法来获取ServletConfig对象，ServletConfig对象可以获取到Servlet的信息，ServletName、ServletContext、InitParameter、InitParameterNames，通过查看ServletConfig这个接口就可以知道。 ServletConfig接口又可以获取ServletContext对象，具体内容下面讲解。 GenericServlet类内容 这个类实现了Servlet和ServletConfig的9个方法。其中init方法有两个，一个是带参数ServletConfig的，一个是无参的方法。 12345678910private transient ServletConfig config;public ServletConfig getServletConfig() { return this.config;}public void init(ServletConfig config) throws ServletException { this.config = config; this.init();}public void init() throws ServletException {} 通过这几个方法一起看，首先看init(ServletConfig config)方法，因为只有init(ServletConfig config)中带有ServletConfig对象，为了方便能够在其他地方也能直接使用ServletConfig对象，而不仅仅局限在init(ServletConfig config)方法中，所以创建一个私有的成员变量config，在init(ServletConfig config)方法中就将其赋值给config，然后通过getServletConfig()方法就能够获取ServletConfig对象了。而当想在init方法中做一些别的事情，就需要重写init(ServletConfig config)方法，这样的话在重写的方法中必须调用父类的init(ServletConfig config)方法，即super.init(ServletConfig config),否则GenericServlet类中的成员变量config会一直是null值，无法再得到ServletConfig对象。增加一个init()方法，那么需要在init内初始化别的数据时，就只需要重写init()方法，不需要覆盖init(ServletConfig config)了，仍然可以得到config对象。 1public abstract void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException; 这是GenericServlet类中的service方法，是一个抽象方法，那么也就是还有一个子类继承它，即HttpServlet类。这个类实现了service方法的各种细节，通过类名也可知道和http协议有关系了。 HttpServlet类内容 包含各种常量，比如GET和POST请求，还有各种请求的处理方法。 service(ServletRequest req, ServletResponse res)方法 123456789101112public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException { HttpServletRequest request; HttpServletResponse response; try { request = (HttpServletRequest)req; response = (HttpServletResponse)res; } catch (ClassCastException var6) { throw new ServletException(&quot;non-HTTP request or response&quot;); } this.service(request, response);} 该方法只是把ServletRequest和ServletResponse这两个对象强转为HttpServletRequest和HttpServletResponse对象。之后，在调用service(HttpServletRequest req, HttpServletResponse resp)方法，这个方法就是判断浏览器过来的请求方式是哪种，每种的处理方式不一样，我们常用的就是get，post，并且，我们处理的方式可能有很多的内容，所以，在该方法内会将get，post等其他5种请求方式提取出来，变成单个的方法，然后我们需要编写servlet时，就可以直接重写doGet或者doPost方法就行了，而不是重写service方法，更加有针对性。 所以，以后编写servlet程序时，只需要继承于HttpServlet类，只要重写两个方法，doGet()和doPost()。 ServletConfig类是servlet程序的配置信息类，由Tomcat负责创建，为每一个Servlet程序都创建一个ServletConfig对象。 三大作用 可以获取Servlet程序的别名servlet-name的值。（getServletName()） 获取初始化参数init-param（只是该Servlet下的初始化参数)。（getInitParameter()） 获取ServletContext对象。（getServletContext()） 12345678910111213&lt;servlet&gt; &lt;!--servlet-name给程序起一个别名--&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!--servlet的全类名--&gt; &lt;servlet-class&gt;servlet.HelloServlet&lt;/servlet-class&gt; &lt;!--配置参数--&gt; &lt;init-param&gt; &lt;!--参数名--&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;!--参数值--&gt; &lt;param-value&gt;root&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt; 1234567891011121314151617@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { ServletConfig servletConfig = getServletConfig(); System.out.println(&quot;servlet2的get请求&quot;); //获取Servlet程序别名 System.out.println(servletConfig.getServletName()); //获取初始化参数init-param System.out.println(servletConfig.getInitParameter(&quot;username&quot;)); System.out.println(servletConfig.getInitParameter(&quot;url&quot;)); //获取ServletContext对象 System.out.println(servletConfig.getServletContext()); Enumeration&lt;String&gt; initParameterNames = servletConfig.getInitParameterNames(); while(initParameterNames.hasMoreElements()){ String name = initParameterNames.nextElement(); System.out.println(name+&quot;:&quot;+servletConfig.getInitParameter(name)); }} ServletContext类 ServletContext 是一个接口，它表示 Servlet 上下文对象 一个 web 工程，只有一个 ServletContext 对象实例。 ServletContext 对象是一个域对象。 ServletContext 是在 web 工程部署启动的时候创建。在 web 工程停止的时候销毁。 什么是域对象? 域对象，是可以像 Map 一样存取数据的对象，叫域对象。 这里的域指的是存取数据的操作范围，整个 web 工程。 四大作用 获取 web.xml 中配置的上下文参数 context-param.全局初始化参数，每个Servlet都可以得到该值（getServletContext()） 获取当前的工程路径，格式: /工程路径。（getContextPath()） 获取工程部署后在服务器硬盘上的绝对路径。（getRealPath()） 存取数据。（setAttribute(),getAttribute()） 1234567891011protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ServletConfig servletConfig = getServletConfig(); ServletContext servletContext = servletConfig.getServletContext(); //获取web.xml配置的上下文参数context-param String username = servletContext.getInitParameter(&quot;username&quot;); System.out.println(&quot;context参数username：&quot;+username); //获取当前工程路径 System.out.println(&quot;当前工程路径为&quot;+servletContext.getContextPath()); //获取工程部署后在硬盘上的绝对路径 System.out.println(&quot;绝对路径为&quot;+servletContext.getRealPath(&quot;/&quot;));} HttpServletRequest类每次只要有请求进入 Tomcat 服务器，Tomcat 服务器就会把请求过来的 HTTP 协议信息解析好封装到 Request 对象中。 然后传递到 service 方法（doGet 和 doPost）中给我们使用。我们可以通过 HttpServletRequest 对象，获取到所有请求的 信息。 常用api 12345678910111213@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //获取请求的资源路径 System.out.println(&quot;URI--&gt;&quot;+req.getRequestURI()); //获取请求的绝对路径 System.out.println(&quot;URL--&gt;&quot;+req.getRequestURL()); //获取客户端ip地址 System.out.println(&quot;ip--&gt;&quot;+req.getRemoteAddr()+&quot; port--&gt;&quot;+req.getServerPort()); //获取请求头 System.out.println(&quot;header--&gt;&quot;+req.getHeader(&quot;User-Agent&quot;)); //获取请求方式 System.out.println(&quot;method--&gt;&quot;+req.getMethod());} 获取请求参数 12345678910&lt;body&gt; &lt;form action=&quot;http://localhost:8080/2_Servlet/param&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; 兴趣爱好：&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;java&quot;&gt;Java &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;C++&quot;&gt;C++ &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;C#&quot;&gt;C#&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交吧&quot;&gt; &lt;/form&gt;&lt;/body&gt; 12345678910protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(&quot;******GET******&quot;); //获取请求参数 System.out.println(request.getParameter(&quot;username&quot;)); System.out.println(request.getParameter(&quot;password&quot;)); //只能获取到第一个 System.out.println(request.getParameter(&quot;hobby&quot;)); //获取多个值 System.out.println(Arrays.asList(request.getParameterValues(&quot;hobby&quot;)));} post请求中同样，但是会出现中文乱码，需要设置请求体的字符集为utf8. 1request.setCharacterEncoding(&quot;utf-8&quot;); 请求转发请求转发是指，服务器收到请求后，从一个资源跳转到另一个资源的操作叫请求转发。 浏览器地址栏没有发生变化 是同一次请求 共享Request域中的数据 可以转发到WEB-INF下 不可以访问工程以外的资源 123456789101112131415161718//servlet1中的get方法protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String username = request.getParameter(&quot;username&quot;); System.out.println(&quot;发送的&quot;+username); request.setAttribute(&quot;password&quot;,&quot;123456&quot;); //务必以&quot;/&quot;开头，表示地址为hhtp://ip:port/工程名/ RequestDispatcher requestDispatcher = request.getRequestDispatcher(&quot;/servlet2&quot;); requestDispatcher.forward(request,response);}//servlet2中的get方法protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String username = request.getParameter(&quot;username&quot;); System.out.println(&quot;转发收到的&quot;+username); Object password = request.getAttribute(&quot;password&quot;); System.out.println(password);}//浏览器地址栏http://localhost:8080/2_Servlet/servlet1?username=root base标签可以设置当前页面的相对路径工作时，参照哪个相对路径进行跳转。 1&lt;base href=&quot;http://localhost:8080/07_servlet/a/b/&quot;&gt; Web中”/“的意义 如果被浏览器解析，得到的地址是：http://ip:port/ 如果被服务器解析，得到的地址是：http://ip:port/工程路径 特殊情况：response.sendRediect(“/“) 会把”/“发给浏览器解析，得到http://ip:port/ HttpServletResponse类HttpServletResponse 类和 HttpServletRequest 类一样。每次请求进来，Tomcat 服务器都会创建一个 Response 对象传 递给 Servlet 程序去使用。HttpServletRequest 表示请求过来的信息，HttpServletResponse 表示所有响应的信息， 我们如果需要设置返回给客户端的信息，都可以通过 HttpServletResponse 对象来进行设置。 两个输出流字节流：getOutputStream() 字符流：getWriter() 两个流同时只能使用一个。 向客户端回传数据 123456789101112@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(resp.getCharacterEncoding());//默认ISO-8859-1 // //设置服务器字符集 // resp.setCharacterEncoding(&quot;UTF-8&quot;); // //通过响应头，设置浏览器也使用utf8 // resp.setHeader(&quot;Content-Type&quot;,&quot;text/html;charset-UTF-8&quot;); //也可以直接设置Content-Type，但要在获取流之前设置 resp.setContentType(&quot;text/html;charset-UTF-8&quot;);//推荐使用， 它会同时设置服务器和客户端都使用 UTF-8 字符集，还设置了响应头 PrintWriter writer = resp.getWriter(); writer.write(&quot;响应内容&quot;);} 请求重定向是指客户端给服务器发请求，然后服务器告诉客户端说，我给你一些地址。你去新地址访问。叫请求 重定向（因为之前的地址可能已经被废弃）。 浏览器地址栏会发生变化 两次请求 不能共享request域中的数据 不能访问到WEB-INF下的资源 可以访问工程外的资源，比如百度 123456789protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(&quot;经过了response1&quot;); // //设置响应码302，表示重定向 // response.setStatus(302); // //设置响应头，说明新的地址在哪里 // response.setHeader(&quot;Location&quot;,&quot;http://localhost:8080/2_Servlet/response2&quot;); response.sendRedirect(&quot;/2_Servlet/response2&quot;);//推荐使用 //也可以重定向到其他资源，比如百度} 1234567protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(&quot;response2's results&quot;); response.getWriter().write(&quot;response2's results&quot;);}//结果经过了response1response2's results","link":"/2022/01/08/Servlet%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"java基础","slug":"java基础","link":"/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"java集合","slug":"java集合","link":"/tags/java%E9%9B%86%E5%90%88/"},{"name":"experience","slug":"experience","link":"/tags/experience/"},{"name":"位运算","slug":"位运算","link":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"acm","slug":"acm","link":"/tags/acm/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"搜索","slug":"搜索","link":"/tags/%E6%90%9C%E7%B4%A2/"},{"name":"题解","slug":"题解","link":"/tags/%E9%A2%98%E8%A7%A3/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"树状数组","slug":"树状数组","link":"/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"JDBC","slug":"JDBC","link":"/tags/JDBC/"},{"name":"JavaWeb","slug":"JavaWeb","link":"/tags/JavaWeb/"}],"categories":[{"name":"science","slug":"science","link":"/categories/science/"},{"name":"life","slug":"life","link":"/categories/life/"}]}