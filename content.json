{"pages":[],"posts":[{"title":"Hello Blog","text":"2021年10月21日，我终于开通了个人博客。 让我下定决心写博客的原因，是在昨天下午做到求数组中和为k的子数组个数的题目时，用到前缀和+哈希表，而这道题让我想起8月28号的CCPC网络赛F题Command Sequence也是一道前缀和+哈希表的题目，那时我却没有做出来，意识到自己已经打了将近半年的acm，知识还是很混乱的，所以下决心记录梳理一下知识。","link":"/2021/10/21/Hello-Blog/"},{"title":"子数组和为k问题","text":"关于各种子数组的和小于(大于)或等于k的最长最短子数组或者求有多少个这样的子数组问题,可以分成两类。 当数组全是正数的时候，用双指针算法 当数组存在负数的时候，用前缀和+哈希表优化，也可使用单调队列优化 求一个数组中和为k的子数组的个数如果直接暴力做，复杂度为$O(n^2)$​​​​,不能通过。此题考虑前缀和+哈希表优化。我们定义$pre[i]$​​​为$[0,i]$​里所有的数的和，则$pre[i]$由$pre[i-1] + nums[i]$​​​​得来，即$$pre[i] = pre[i-1]+nums[i]$$那么找到一个子数组$[j…i]$和为$k$​这个条件可以转化成$$pre[j-1]==pre[i]-k$$于是问题就变为考虑以$i$结尾的和为$k$的连续子数组时，只要统计有多少个前缀和为$pre[i]-k$的$pre[j]$​​​​即可。 我们建立哈希表$mp$​，以和为键值，到当前位置出现次数为对应值，记录$pre[i]$出现的次数，从左往右边更新边计算答案，那么以$i$为结尾的答案$mp[pre[i]-k]$即可在$O(1)$时间内得到。最后答案即为所有$mp[pre[i]-k]$​​的和。 需要注意的是，因为我们从左往右边更新边计算时保证了$mp[pre[i]-k]$​​里记录的$pre[j]$​​的下标范围是$0 \\leq j \\leq i$​​.同时，由于$pre[i]$​​只与前一项$pre[j-1]$​有关，因此我们不必建前缀和数组，直接使用$pre$​​变量来记录和即可。 123456789101112int subarraySum(vector&lt;int&gt;&amp; nums,int k) { unordered_map&lt;int,int&gt; mp; int count = 0,pre = 0; mp[0] = 1; //当前前缀和就为k时是存在一个子数组的 for(auto x:nums){ pre += x; if(mp.find(pre-k) != mp.end()) count += mp[pre-k]; mp[pre]++; } return count;} 求一个数组中和为数组长度的子数组个数这个题是在训练群中听学长的面试官同事提的。咋一看比较没有思路，但是把数组每个元素减1，就变成了子数组和为0，和上题一样。 求一个数组中和为k的最长子数组长度仍然是前缀和+哈希表方式。这时哈希表以和为键，以右端点为对应值。当存在$mp[pre[i]-k]$​​时，也就是找到了一段和为$k$的子数组，这时比较$maxlen$和$i-mp[pre-k]$​​​更新答案即可。 12345678910111213int maxlenOfArray(vector&lt;int&gt;&amp; nums,int k) { unordered_map&lt;int,int&gt; mp; mp[0] = -1; int maxlen = 0,pre = 0; for(int i = 0;i &lt; nums.size();i++) { pre += nums[i]; if(mp.find(pre-k)) maxlen = maxlen&gt;i-mp[pre-k]?maxlen:i-mp[pre-k]; if(mp.find(pre) == mp.end()) mp[pre] = i//总是在第一次遇到这个和时插入map，使这个值尽可能早 } return maxlen;} 求一个01串中最长01数量相等的子串此题将$0$​看做$-1$，则是找和为$0$​​的最长子串长度。 2021 CCPC Command Sequence题意一个机器人能上下左右移动，分别对应字符$UDLR$​.给定一个机器人移动序列字符串，问有多少个子串可以使其按照子串的顺序来走能回到原点。 分析此题我们直接将每个字符看成一个数字，且上下互为相反数，左右互为相反数，那么就是找到这个数字序列有多少个和为$0$​​的子序列。依旧是前缀和+哈希表结构。需要注意的是，由于一个$2$​​可以由两个$-1$​​抵消，所以上下和左右代表的数字不能太接近。这里字符串长度最大为$10^5$​​，所以我们可以让$U$​和$D$​代表$1$​和$-1$​，让$L$​和$R$​代表$100000$​和$-100000$​​​​​​​​。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;unordered_map&gt;using namespace std;typedef long long ll;const int maxn = 1e5 + 10;int t, n;ll a[maxn];char s[maxn];int main(){ cin &gt;&gt; t; while (t--) { cin &gt;&gt; n; cin &gt;&gt; s + 1; for (int i = 1; i &lt;= n; i++) { if (s[i] == 'U') a[i] = 1; if (s[i] == 'D') a[i] = -1; if (s[i] == 'L') a[i] = 100000; if (s[i] == 'R') a[i] = -100000; } unordered_map&lt;ll, int&gt; mp; mp[0] = 1; ll pre = 0, count = 0; for (int i = 1; i &lt;= n; i++) { pre += a[i]; if (mp.find(pre) != mp.end()) count += mp[pre]; mp[pre]++; } cout &lt;&lt; count &lt;&lt; endl; } return 0;} 数学？题目描述给你一个长度为$n$​的数组$a$​和一个正整数$k$​，问$a$​有多少个和$\\geq k$​的​​连续子序列。 分析如果连续子序列$[l,r]$的和已经$\\geq k$,那么从$l$到$r+1$、从$l$到$r+2$​、$\\cdots$、从$l$到$n$的和都$\\geq k$。这样的子序列有$n-r+1$个。因此，我们可以枚举$l$从$1$到$n$，对于每一个$l$，找到最小的$r$使得$\\sum[l,r]\\geq k$,那么从$l$开始的符合条件的子序列就有$n-r+1$个。 对于给定的左边界$l$，如何快速找到最小满足条件的$r$,可以使用滑动窗口的办法。 我们得到上一个$l$的最小$r$之后，记录下这个最小的$r$和$[l,r]$的和。当$l$变成$l+1$时，让上次的和减去$a[l]$,得到的是$[l+1,r]$的和。 如果这个和仍大于等于$k$，那么$r$仍然是最小的$r$，更新答案即可。 否则$r$向右移动变成$r+1$，和也加上$a[r+1]$，直到和又大于等于$k$，此时的$r$又是最小的$r$。 上述过程中，一旦$r$​超过数组范围就结束了。 $r$从$1$移到了$n$，时间复杂度为$O(n)$。 代码123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;typedef long long ll;ll a[100010];int main() { int n; ll k; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) { scanf(&quot;%lld&quot;, &amp;a[i]); } ll ans = 0; // 答案 ll left = 0, right = 0; // l和r初始值都是0 ll sum = a[0]; // sum代表[left, right]的和 while (right &lt; n) { if (sum &gt;= k) { // sum[l, r] &gt;= k ans += n - right; sum -= a[left++]; // 枚举下一个l（l++），相应地sum也要减去不在范围内的a[l] } else { // sum[l, r] &lt; k，还没找到最小的r sum += a[++right]; // r右移并累加入总和 } } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2021/10/21/%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E4%B8%BAk%E9%97%AE%E9%A2%98/"},{"title":"图论(1)","text":"TarjanTarjan算法是一种非常实用的图论算法，可以解决连通块、割点、缩点、桥等问题。 建图建图采用链式前向星方式。 12345678910111213141516171819int head[maxn]; //表头int nxt[maxn]; //链表下一位int edge[maxn]; //该边终点int weight[maxn]; //该边的权值int tot; //边的数量void addEdge(int u,int v,int w){ edge[++tot] = v; weight[tot] = w; nxt[tot] = head[u]; head[u] = tot;}//遍历方式void traverse(){ for(int i=1;i&lt;=n;i++) for(int j=head[i];j;j=nxt[j]) cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;edge[j]&lt;&lt;endl;} 强连通分量强连通分量，即图的一个子集。如果两个顶点可以相互通达，则称这两个点强连通(strongly connected).如果有向图的每两个顶点都强连通，则称图G为强连通图。有向图的强连通子图，称为强连通分量。 弄懂Tarjan算法需要明白最重要的两个数组：$dfn、low$​​. $dfn[x]$​​记录每个点最早被遍历的时间，即在dfs过程中$x$的时间戳。 $low[x]$​​​表示从$x$​​处搜索，能够回溯到的最早被遍历的点的时间戳。 用$vis$数组来记录每个点的分块编号，或者换个写法表示每个点所在的连通块的根的编号也可。 使用dfs遍历图，每次访问到新节点$u$​时，向栈中压入$u$​，记录$dfn[u]==low[u]$​，并依次访问该节点的每一个相邻节点$v$​.会出现三种情况： $dfn[v]==0$:此时$v$​​还没有搜索到，直接对$v$​进行递归，会得到$low[v]$​,故更新$low[u] = min(low[u],low[v])$​​ $vis[v]==0$:此时$v$​早在$u$​之前就已经访问过了，但是$u$​的邻接点还未遍历完全，更新$low[u]=min(low[u],dfn[v])$​. $vis[v]!=0$:此时$v$已经操作完全，略过。 对于第二种情况的$v$​，我们用其$dfn$值更新$u$的$low$值的原因是，从$u$处能搜到曾经搜过的$v$，那么从$v$开始就有可能存在一个强联通块包含了$u$，因此我们将$u$的low值更新，再通过回溯时对low值的更新，一步步更新回$v$点，若$low[v]$与$dfn[v]$相等，就说明从$v$开始绕了一圈又找到了$v$，也就是说找到了强连通分量。那么如何对应地找到其中所有的节点呢？我们通过栈来实现，在dfs过程中，若遇到没搜过的点，则将其入栈，最后在$low[u]=dfn[u]$处，因为从$u$处最终能走回$u$，回溯到$u$​时，途中的所有节点都在栈中，而中途可能遇到的分支都会在相同的过程中全部出栈（不在环中的自成一个强连通分量），因此从栈顶到栈中$u$的位置，中间的节点正好在一个强连通分量中，所以我们只需要不断弹栈，直到将$u$弹出栈，所有弹出的元素都归为一个强联通块中。可以证明，这样求得的强联通块是最大强联通块，将强联通块抽象成点，这便是缩点 12345678910111213141516171819202122232425void Tarjan(int u){ dfn[u] = low[u] = ++tit; //时间戳 st.push(u); for(int i=head[u];i;i=nxt[i]) { int v = edge[i]; if(!dfn[v]){ Tarjan(v); low[u] = min(low[u],low[v]); } else if(!vis[v]) low[u] = min(low[u],dfn[v]); } if(dfn[u]==low[u]) { vis[u] = ++cnt; //连通块编号 while(st.top()!=u) { vis[st.top()] = cnt; //栈顶到u的一块都在一个连通块中 st.pop(); } st.pop(); }} 上题目校园网 缩点 割点割点是指若将连通图的某个点及其连接的边删去后，图中的连通分量增加，则称这个点为割点。 对于点$u$，假如其从$fa$搜索而来，连接着某点$v$,若$low[v] \\geq dfn[u]$,则$u$​是割点。 可以画出图来理解，如果我们将$u$和其连接的边删掉，$v$和$fa$必然不属于同一个连通块。若删掉后$v$和$fa$属于同一个连通块，那么$low[v]$必然会小于$dfn[u]$。通过这一点我们可以对每个走过的点都用其$dfn$值更新$u$的$low$值，就是为了保证求出的割点一定保证$fa$和$v$不在任何同一个连通块中。 那么这时我们会考虑一个特殊的点：第一个被搜索的点，这个点没有$fa$。该如何确定这个点是不是割点呢？我们直接记录其子树数量，如果其子树数量大于1，那么就是割点，因为把它去掉，其子树不能相互到达。 于是算法模板如下 12345678910111213141516171819202122void tarjan(int u,int root){ dfn[u] = low[u] = ++tit; int childtree = 0; //根的子树数量 for(int i=head[u];i;i=e[i].nxt) { int v = e[i].to; if(!dfn[v]){ tarjan(v,root); low[u] = min(low[u],low[v]); if(low[v]&gt;=dfn[u]&amp;&amp;u!=root){ cut[u] = true; //记录u节点为割点 } if(u==root) childtree++; } else low[u] = min(low[u],dfn[v]); } if(childtree&gt;=2&amp;&amp;u==root) cut[u] = true; // 根节点也为割点} 根据上述求法，我们还可以统计出删掉割点$u$之后连通块增加的个数 对于第一个搜索的点，连通块增加的个数是$childtree-1$。 对于其他点，连通块增加的个数是$u$被判为割点的次数 12345678910if(low[v]&gt;=dfn[u]&amp;&amp;u!=root) cut[u] = true;改为if(low[v]&gt;=dfn[u]&amp;&amp;u!=root) ++delta[u]; //删去u增加的连通图数量if(childtree&gt;=2&amp;&amp;u==root) cut[u] = true; 改为if(childtree&gt;=2&amp;&amp;u==root) delta[root] = childtree-1; 上例题 割点 嗅探器 桥在无向图中，删去一条边，使得图的连通块数量增加，则称这条边为桥。 在$tarjan$​的过程中，若$u$连接着$v$,$low[v]&gt;dfn[u]$,则连接$u、v$的边是桥，可画图理解。 123456789101112131415161718void Tarjan(int u, int fa){ dfn[u] = low[u] = ++cnt; //桥在无向图中是两条相同的边，所以边一般从0开始编号 for (int i = head[u]; i != -1; i = nxt[i]) { int v = edge[i]; if (dfn[v] == 0) { Tarjan(v, u); low[u] = min(low[u], low[v]); if (low[v] &gt; dfn[u]) bridge[i] = bridge[i ^ 1] = true;//i和i^1这两条边是同一条边，是桥 } else if (fa != v) low[u] = min(low[u], dfn[v]); }} 上例题 炸铁路 拓扑排序在图论中，拓扑排序(Topological Sorting)是一个有向无环图(DAG,Directed Acyclic Graph)的所有顶点的线性序列。且该序列必须满足以下两个条件： 每个顶点出现且仅出现一次。 若存在一条从顶点A到顶点B的路径，则在序列中顶点A在顶点B的前面出现。 有向无环图(DAG)才有拓扑排序，非DAG图没有拓扑排序一说。根据定义可知，一个DAG图的拓扑排序也许不止一个。 直接上题 摄像头 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;const int maxn = 510;int edge[maxn],head[maxn],nxt[maxn];int ind[maxn],outd[maxn];int has[maxn],a[maxn];int n,tot,ans;queue&lt;int&gt; q;void addEdge(int u,int v){ edge[++tot] = v; nxt[tot] = head[u]; head[u] = tot;}int main(){ ios::sync_with_stdio(false); cin.tie(0),cout.tie(0); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { int m,y; cin&gt;&gt;a[i]&gt;&gt;m; has[a[i]] = 1; //该位置被监视 while(m--) { cin&gt;&gt;y; addEdge(a[i],y); outd[a[i]]++,ind[y]++; } } for(int i=1;i&lt;=n;i++) { if(ind[a[i]]==0) q.push(a[i]); } while(!q.empty()) { int u=q.front(); q.pop(); if(has[u]) ans++; //砸掉摄像头，该位置不被监视 for(int i=head[u];i;i=nxt[i]) { int v=edge[i]; ind[v]--; if(ind[v]==0&amp;&amp;has[v]==1) q.push(v); } } if(ans==n) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;n-ans&lt;&lt;endl; return 0;} 旅行计划","link":"/2021/10/27/%E5%9B%BE%E8%AE%BA-1/"},{"title":"图论(2)","text":"最短路最短路是非常常见的问题，有单源最短路和全源最短路，求解方法和各种应用也很多。来看一些常用、基本的最短路算法。 图的建立 用多个数组或一个结构体来直接存边。建图方便，操作效率低，在$Kruskal$算法中有应用。 邻接矩阵，$f[u][v]=w$表示$u$到$v$有一条权值为$w$的边。建图方便，遍历复杂度高，空间花费巨大，不适用于有重边的情况，一般用于稠密图，$Floyd$算法一般使用邻接矩阵。 vector存边。建图方便，可对边排序，操作效率高。 链式前向星。类似邻接表，理解后背模板即可，操作效率高，后文代码均使用此方式建图。 单源最短路单源最短路径指的是求从图上一个起点出发到其他所有点的最短路径。 以下默认一张图中$n$个点，$m$条边。 $Bellman-Ford$算法Bellman-Ford算法最核心的操作是松弛操作，其思想为：用当前节点的最短路去更新其邻接点的最短路。 容易想到，一条最短路上最多只有$n$个点和$n-1$​条边，因此我们只需要对每一条边尝试松弛$n-1$次，若存在最短路，则这些操作后一定找齐了所有的最短路，且所有边均不能再松弛操作；若仍能进行松弛操作，表示存在负环。 Bellman-Ford算法非常暴力，时间复杂度很高。显然，在对一条边进行松弛时，只有它的前驱节点已经进行过最短路的估计，即$dist[u]$不为$\\infty$时，边$(u,v)$才能被松弛。在Bellman-Ford算法中，有大量的边在遍历时不需要被松弛。 我们可以利用队列进行优化得到$SPFA$​算法。 $SPFA$算法对于Bellman-Ford，将所有更新过的点加入队列，每次取出一个点进行松弛，直到队列为空，这就是$spfa$​. 1234567891011121314151617181920212223242526void spfa(int s){ for(int i=1;i&lt;=n;i++) dist[i] = INF; //设置初始距离为无穷大，用来松弛 queue&lt;int&gt; q; dist[s] = 0; //到自身距离为0 q.push(s); flag[s] = true; //标记入队 while(!q.empty()) { int u = q.front(); q.pop(); flag[u] = false; //标记出队 for(int i=head[u];i;i=nxt[i]) { int v = edge[i],w = weight[i]; if(dist[v]&gt;dist[u]+w){ dist[v] = dist[u]+w; //松弛操作 if(!flag[v]){ q.push(v); flag[v] = true; //标记入队 } } } }} 但是即使使用队列优化过，$spfa$​时间复杂度依然很高，最坏情况下达到$O(|V|\\cdot |E|)$​.很容易被卡掉。 负环判定$spfa$的一个优点在于可以判别图中是否存在负环。判定方法是：记录每个点的入队次数，如果这个次数达到了总的节点数则说明图中存在负环。 注意是判入队次数而不是松弛次数，如果存在重边导致了多次松弛，会对松弛次数的判断产生影响，可能会被$hack$。 123456789if(dist[v]&gt;dist[u]+w){ dist[v] = dist[u] + w; //松弛操作 if(!flag[v]){ if(++cnt[v]&gt;=n) //判入队次数，当大于等于n时说明存在负环 printf(&quot;存在负环\\n&quot;); q.push(v); flag[v] = true; }} 但是这种方法可能会爆$int$，原因在于要让入队次数达到$n$，则遍历的总个数最大可达$n^2$. 考虑换一种思路，如果不存在负环，那么从某点出发到每个点的最短路应当是不存在环的。因此我们可以判断最短路径的路径边数是否小于$n$(即经过点数小于等于n，没有任何一个点重复走过)，来更高效地判断负环。 12345678910if(dist[v]&gt;dist[u]+w){ dist[v] = dist[u] + w; if(!flag[v]){ cnt[v] = cnt[u]+1; //v的最短路上经过点数比u多1 if(cnt[v]&gt;=n) printf(&quot;存在负环\\n&quot;); flag[v] = 1; q.push(v); }} 负环 $Dijkstra$算法$spfa$如此之慢，我们需要一种更快更稳定的最短路算法。 $dijkstra$​算法的思想是贪心+$bfs$​求最短路，它只适用于不含负边权的图。在稠密图中表现优秀。 我们将点分成两类，一类是已经确定最短路径的点，称为“白点”，另一类是未确定最短路径的点，称为“蓝点”。 $dijkstra$流程如下： 初始化$dist[s]==0$,其余节点的$dist$值为$\\infty$. 找到一个$dist$​最小的蓝点$u$​，将节点$u$​变成白点，即找到最短路。 遍历$u$的所有出边$(u,v,w)$，若$dist[v]&gt;dist[u]+w$,则$dist[v]=dist[u]+w$. 重复$2,3$两步，直到所有点变成白点。 这样做的时间复杂度是$O(n^2)$​​。 图解 另初始节点$s$为1，把$dist[s]$初始化为0，其余点初始化为$\\infty$. 第一轮循环找到$dist$最小的点$1$,将$1$变成白点，对所有与$1$相连的蓝点的$dist$进行松弛，使$dist[2]=2,dist[3]=4,dist[4]=7$ 第二轮循环找到$dist$最小的点$2$，将$2$变成白点，对所有与2相连的蓝点的$dist$​​进行松弛，使$dist[3]=3,dist[5]=4$ 第三轮循环找到$dist$最小的点是$3$，将3变成白点，对所有与3相连的蓝点进行松弛，使$dist[4]=4$ 接下来两轮循环分别将4、5设置为白点，算法结束，所有点最短路径找到。 为什么$dijkstra$​不能处理负边权图 我们来看下面这张图 2到3的边权为-4，显然从1到3的最短路径为-2(1-&gt;2&gt;3).但在循环开始时程序会找到当前$dist$最小的点3，并将其标记为白点。 这时$dist[3]=1$,然而1并不是起点到3的最短路径，且3已经被标记为白点，所以$dist[3]$不会再被修改。 我们在边权为负时得到了错误的答案。 $dijkstra$的堆优化观察流程，发现步骤2可以优化。我们用小根堆对$dist$数组进行维护，在$O(\\log n)$​的时间取出堆顶元素并删除，用$O(\\log n)$遍历每条边，总的时间复杂度为$O((n+m)\\log n)$. $dijkstra$​的正确性我们可以考虑反证法。假如点$u$在出队后优先队列中还有点$y$可以使$dist[u]$减小，那么$dist[y]$必然小于$dist[u]$.而根据优先队列的性质，$dist[u]$是堆中最小的元素，即$dist[u]\\leq dist[y]$,产生矛盾。因此可以保证$u$出队后$dist[u]$是最小的。 123456789101112131415161718192021222324252627282930313233struct Node{ int id; int val; Node(){} Node(int id,int val): id(id),val(val) {} bool operator &lt; (const Node s) const{ //重载小于号，使其为小根堆 return val&gt;s.val; }};priority_queue&lt;Node&gt; q;void dijkstra(int s){ for(int i=1;i&lt;=n;i++) dist[i] = INF; //设置初始距离为无穷大 dist[s] = 0; q.push(Node(s,dist[s])); while(!q.empty()) { Node now = q.top(); q.pop(); int u = now.id; if(vis[u]) continue; //如果已经找到最短路，跳过 vis[u] = true; for(int i=head[u];i;i=nxt[i]){ int v = edge[i],w=weight[i]; if(dist[v]&gt;dist[u]+w){ dist[v] = dist[u]+w; if(!vis[v]) q.push(Node(v,dist[v])); } } }} 上模板 $DAG$图最短路$DAG$图即有向无环图，可以直接对图进行拓扑排序，按照点的顺序一次进行松弛操作即可。 正确性拓扑排序后松弛的顺序即是最终结果中最短路边的顺序，每次松弛前边的起点都已经找到最短路，满足最优子结构。 时间复杂度线性 全源最短路全源最短路径指求图上任意两点之间的最短路径。 常见算法包括$Floyd$算法、$Johnson$算法。 $Floyd$​算法$floyd$算法是一种动态规划求解最短路的方法，其基本思想是：对于每个起点和终点，枚举中间点，进行状态转移。 转移方程为$d_{x,y}=min(d_{x,k}+d_{k,y}|1\\leq k \\leq n)$ 时间复杂度为$O(n^3)$ 1234for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]); $floyd$算法还可以判断图中两个点是否连通，在数据范围较小时非常好用。 上例题Cow Contest S $Johnson$算法$johnson$算法求任意两点间的最短路，是通过枚举起点，跑$n$次$dijkstra$算法解决，算法的时间复杂度为$O(nm\\log m)$，在稀疏图上比$floyd$算法更加优秀。 但是$dijkstra$算法不能正确求解带负权边的最短路问题，因此我们需要在原图上做预处理，确保所有的边权非负。 一种任意想到的方法是给所有边的边权同时加上一个正数$x$，从而让所有的边权非负。如果新图上起点到终点的最短路经过了$k$条边，则将最短路减去$kx$得到实际最短路。 但这种方法是错误的。因为如果原图上最短路边数较多，再每条边加上正数$x$后，新图可能存在一条边数更少的最短路，这时已经不是原来的最短路了。 $johnson$​算法通过另一种方法来给每条边重新标注边权。 我们建立一个超级源点（编号为$0$），从这个点向每一个点连一条权值为$0$的边。 首先可以用$spfa$​​求出源点到每个节点的最短路，记为$h_i$​。 假设原图中存在一条从$u$​到$v$​，边权为$w$​的边，我们将该边的边权重新设置为$w+h_u-h_v$​。 接下来以每个点为起点，跑$n$轮$dijkstra$算法即可求出新图任意两点间的最短路。 以$u$​为起点，$v$​为终点的最短路结果求出为$dist[v]$​​,实际在原图上为$dist[v]+h_v-h_u$​​。 正确性证明 在重新标记的图上，从$s$点到$t$点的一条路径$s-&gt;p_1-&gt;p_2-&gt;\\cdots -&gt;p_k-&gt;t$的长度表达式为： $(w(s,p_1)+h_s-h_{p_1})+(w(p_1,p_2)+h_{p_1}-h_{p_2})+\\cdots +(w(p_k,t)+h_{p_k}-h_t)$ 化简后得到： $w(s,p_1)+w(p_1,p_2)+\\cdots +w(p_k,t)+h_s-h_t$ 无论我们走哪一条路径，$h_s-h_t$的值不变的。这类似于两点间势能差的概念，只与两点位置有关。 为了方便，下面我们就把$d_i$称为$i$点的势能。 新图中的$s-&gt;t$的最短路长度表达式有两部分组成，前面的边权和为$s$到$t$的最短路，后面为两点的势能差。因为两点间的势能差为定值，因此原图上$s-&gt;t$的最短路与新图上$s-&gt;t$的最短路相对应。 至此我们证明了重新标注后图上最短路径仍是原图上的最短路径，接下来需要证明标注后所有边权非负，因为在非负边权上，$dijkstra$才能保证得出正确的结果。 根据三角形不等式，新图上任意一边$(u,v)$​满足：$h_v\\leq h_u+w(u,v)$。这条边重新标注之后的边权为$w’(u,v)=w(u,v)+h_u-h_v\\geq 0$。这样证明了标注后边权均非负。 至此我们证明了$johnson$算法的正确性。 上模板johnson全源最短路 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e5+10;inline int read(){ int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') { if (ch == '-') f = -1; ch = getchar(); } while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') { x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); ch = getchar(); } return x * f;}struct Node{ int id; int val; Node(){} Node(int id,int val): id(id),val(val) {} bool operator &lt; (const Node s) const{ return val&gt;s.val; }};ll head[maxn],nxt[maxn],edge[maxn],weight[maxn];ll dist[maxn];//距离ll d[maxn];ll cnt[maxn];bool vis[maxn];ll tot,n,m;void addEdge(int u,int v,int w){ edge[++tot] = v; weight[tot] = w; nxt[tot] = head[u]; head[u] = tot;}bool spfa(int s){ queue&lt;int&gt; q; for(int i=1;i&lt;=n;i++) d[i] = 63; d[s] = 0; q.push(s); vis[s] = 1; while(!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for(int i=head[u];i;i=nxt[i]) { int v = edge[i],w=weight[i]; if(d[v]-d[u]&gt;w){ d[v] = d[u]+w; if(!vis[v]){ cnt[v] = cnt[u]+1; if(cnt[v]&gt;=n+1) return false; //判负环 q.push(v); vis[v] = 1; } } } } return true;}void dijkstra(int s){ priority_queue&lt;Node&gt; q; for(int i=1;i&lt;=n;i++){ dist[i] = INF; //设置初始距离为无穷大 vis[i] = 0; } dist[s] = 0; q.push(Node(s,dist[s])); while(!q.empty()) { Node now = q.top(); q.pop(); int u = now.id; if(vis[u]) continue; //如果已经找到最短路，跳过 vis[u] = true; for(int i=head[u];i;i=nxt[i]){ int v = edge[i],w=weight[i]; if(dist[v]&gt;dist[u]+w){ dist[v] = dist[u]+w; if(!vis[v]) q.push(Node(v,dist[v])); } } }}int main(){ n =read(),m=read(); while(m--) { int u,v,w; u = read(),v=read(),w=read(); addEdge(u,v,w); } for(int i=1;i&lt;=n;i++) addEdge(0,i,0); //建超级源点 if(!spfa(0)) { cout&lt;&lt;-1&lt;&lt;endl; //存在负环直接退出 return 0; } for(int u=1;u&lt;=n;u++) for(int i=head[u];i;i=nxt[i]) weight[i] += d[u]-d[edge[i]]; for(int i=1;i&lt;=n;i++) { dijkstra(i); ll ans=0; for(int j=1;j&lt;=n;j++) { if(dist[j]==INF) ans += j*1e9; //注意相乘结果需要是long long型（卡这里wa了好久 else ans += (ll)j*(dist[j]+d[j]-d[i]); } printf(&quot;%lld\\n&quot;,ans); } return 0;} 差分约束系统还不会 $K$短路还不会 同余最短路还不会","link":"/2021/10/28/%E5%9B%BE%E8%AE%BA-2/"},{"title":"线段树与树状数组","text":"线段树和树状数组是很常用的数据结构，用来处理区间问题，包括区间的修改和查询。 线段树线段树，顾名思义，是将区间分成一段一段来进行区间操作。对于每个子节点，都表示整个序列的一段子区间；对于叶子节点而言，都表示序列中单个元素信息；子节点不断向自己的父亲节点传递信息，而父节点存储的信息是它每一个子节点信息的整合。 线段树可以维护支持结合律的数据，比如加和，乘法，最大/最小值。 如何进行分段？ 考虑将区间$[l,r]$分成两半$[l,mid]、[mid+1,r]$​,相当于将区间对半分，对于每个区间都这样分段，最终段数为$O(n\\log n)$. 当我们对区间$[l,r]$进行操作时，从最大的区间开始，从此去找对应操作的区间。 $[l,r]$包含在当前节点的左区间内，接着往左区间走 $[l,r]$​包含在当前节点的右区间内，接着往右区间走 $[l,r]$​跨过当前节点区间的中点，左边操作$[l,mid]$​​,右边操作$[mid+1,r]$​ 如此反复，直到找到的区间与操作区间一致，就进行操作。 线段树大致图像如下： 当涉及到区间的修改，如加减、乘除时，我们可以在找到的区间上打上懒标记($lazy tag$​),这样不用每次往下遍历整棵线段树。在进行修改和查询时要注意懒标记的下传，还要向上更新节点维护的值。 线段树1 懒标记的优先级当区间的修改包括了加和乘时，需要设置两个标记，$add$加标记、$mul$乘标记。而这时候需要注意优先级问题。 先进行乘法后进行加法。 如果我维护的值是$a$，我的懒标记有$+b$​和$\\times c$，可以发现$(a+b)\\times c \\neq a\\times c+b$. 而在记录懒标记时，加法和乘法两种标记放到一起，需要确定一个优先级。 我们分析一下两种顺序： 先加后乘：$(a+b)\\times c = a\\times c+b\\times c$ 先乘后加：$a\\times c+b$ 上面先加后乘的式子相当于下面的式子，在加法上面多乘了一个$c$ 所以，只要是先加后乘的式子，只要在$b$上$\\times c$就可以转化为先乘后加的式子 具体操作是在添加乘法标记的时候，先将加法标记$\\times c$即可 懒标记下传推导在传递懒标记$pushdown$时 假设当前节点是$o$,$add[o]$是当前节点的加法标记，$mul[o]$是当前节点的乘法标记，$sum[o]$是当前节点维护的和，$ls$是左儿子的编号，$rs$是右儿子的编号。这里当前节点的值已经维护好，儿子还没维护好。 以左儿子为例，根据先乘后加的顺序，给左儿子乘上自己的乘法标记，再加上自己的加法标记。 $$sum[ls] = sum[ls]\\times mul[o]+add[o]\\times (r-l+1)$$ 这样，左儿子的$sum$值就维护好了。那么如果儿子有懒标记呢？ 如果儿子有懒标记，它的懒标记要维护一个值$s$，它维护后的值$s’$应该是 $$s’ = s\\times mul[ls]+add[ls]$$ 现在又要给它加上父节点$o$的懒标记，那么维护后的值应该是$$\\begin{equation}\\begin{split}s’’&amp;=s’\\times mul[o] + add[o] \\ &amp;=(s\\times mul[ls]+add[ls])\\times mul[o]+add[o] \\ &amp;=s\\times mul[ls]\\times mul[o]+add[ls]\\times mul[o]+add[o]\\end{split}\\end{equation}$$如果$mul[ls]’,add[ls]’$是维护后的懒标记，我们就知道了懒标记应该怎么维护 $$mul[ls]’ = mul[ls]\\times mul[o]$$ $$add[ls]’=add[ls]\\times mul[o]+add[o]$$ 在维护懒标记时，乘法标记乘以父节点的乘标记，加法标记先乘以父节点的乘标记，再加上父节点的加标记即可。 线段树2 模板展开查看代码 >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;const int maxn = 1e5 + 10;inline ll read(){ ll x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') { if (ch == '-') f = -1; ch = getchar(); } while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') { x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); ch = getchar(); } return x * f;}struct node{ int l, r; ll sum, add, mul = 1; //该点维护的和，加标记，乘标记初始为1} tree[maxn &lt;&lt; 2];ll a[maxn];ll n, m, p;inline int ls(int pos) { return pos &lt;&lt; 1; }inline int rs(int pos) { return pos &lt;&lt; 1 | 1; }//向上更新节点维护的和void pushup(int pos){ tree[pos].sum = (tree[ls(pos)].sum + tree[rs(pos)].sum) % p;}void build(int pos, int l, int r) //当前节点，操作区间{ tree[pos].l = l, tree[pos].r = r; if (l == r) { tree[pos].sum = a[l] % p; return; } int mid = l + r &gt;&gt; 1; build(ls(pos), l, mid); build(rs(pos), mid + 1, r); pushup(pos);}//向下传递懒标记void pushdown(int pos){ if (tree[pos].mul != 1) { //更新两个标记与节点维护的和,直接乘 (tree[ls(pos)].mul *= tree[pos].mul) %= p; (tree[rs(pos)].mul *= tree[pos].mul) %= p; (tree[ls(pos)].add *= tree[pos].mul) %= p; (tree[rs(pos)].add *= tree[pos].mul) %= p; (tree[ls(pos)].sum *= tree[pos].mul) %= p; (tree[rs(pos)].sum *= tree[pos].mul) %= p; //已经传递，修改为1 tree[pos].mul = 1; } if (tree[pos].add) { (tree[ls(pos)].add += tree[pos].add) % p; (tree[rs(pos)].add += tree[pos].add) % p; //左子树的sum值加上 节点数*懒标记 (tree[ls(pos)].sum += (tree[ls(pos)].r - tree[ls(pos)].l + 1) * tree[pos].add % p) %= p; //右子树的sum值加上 节点数*懒标记 (tree[rs(pos)].sum += (tree[rs(pos)].r - tree[rs(pos)].l + 1) * tree[pos].add % p) %= p; //已经传递，修改为0 tree[pos].add = 0; }}//加法更新void updateAdd(int pos,int l,int r,int k){ if(tree[pos].l==l&amp;&amp;tree[pos].r==r){ //更新该节点维护的和 (tree[pos].sum += (r-l+1) * k % p) %= p; //更新该节点懒标记 (tree[pos].add += k) %= p; return; } //注意要先pushdown!!! pushdown(pos); int mid = tree[pos].l+tree[pos].r&gt;&gt;1; //只在左儿子节点更新 if(r&lt;=mid) updateAdd(ls(pos),l,r,k); //只在右儿子节点更新 else if(l&gt;mid) updateAdd(rs(pos),l,r,k); //在左右儿子节点更新 else updateAdd(ls(pos),l,mid,k),updateAdd(rs(pos),mid+1,r,k); //最后pushup!!! pushup(pos);}//乘法更新void updateMul(int pos,int l,int r,int k){ if(tree[pos].l==l&amp;&amp;tree[pos].r==r){ //更新该节点维护的和 (tree[pos].sum *= k) %= p; //更新该节点懒标记 (tree[pos].add *= k) %= p; (tree[pos].mul *= k) %= p; return; } //注意要先pushdown!!! pushdown(pos); int mid = tree[pos].l+tree[pos].r&gt;&gt;1; //只在左儿子节点更新 if(r&lt;=mid) updateMul(ls(pos),l,r,k); //只在右儿子节点更新 else if(l&gt;mid) updateMul(rs(pos),l,r,k); //在左右儿子节点更新 else updateMul(ls(pos),l,mid,k),updateMul(rs(pos),mid+1,r,k); //最后pushup!!! pushup(pos);}ll query(int pos,int l,int r){ if(tree[pos].l==l&amp;&amp;tree[pos].r==r){ return tree[pos].sum; } //注意先pushdown!!! pushdown(pos); int mid = tree[pos].l+tree[pos].r&gt;&gt;1; //只在左儿子节点查询 if(r&lt;=mid) return query(ls(pos),l,r); //只在右儿子节点查询 else if(l&gt;mid) return query(rs(pos),l,r); //在左右儿子节点查询 else return (query(ls(pos),l,mid)+query(rs(pos),mid+1,r))%p;}int main(){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;p; for(int i=1;i&lt;=n;i++) a[i] = read(); build(1,1,n); while(m--) { int opt; ll x,y,k; opt = read(),x = read(),y = read(); if(opt==1){ k = read(); updateMul(1,x,y,k); } else if(opt==2){ k = read(); updateAdd(1,x,y,k); } else if(opt==3){ printf(&quot;%lld\\n&quot;,query(1,x,y)); } } return 0;} 树状数组单点修改，区间查询树状数组用于维护前缀和，可以单点修改。 大致图像如下 每个节点维护值的长度是该节点二进制最低位1代表的值。 树状数组中$lowbit$​函数是得到一个数的最低位1代表的值，比如$lowbit(5)=1,lowbit(4)=4$. 如果改变$x$位置的值，就加上该位置的$lowbit$，一直加到$n$，就维护了树状数组。 查询时反过来，从$x$位置开始，减去当前位置的$lowbit$，一直减到$1$，就得到$x$位置的前缀和。 树状数组1 12345678910111213141516171819202122232425262728293031323334353637383940414243int a[maxn],n,m;ll tree[maxn]; //树状数组int lowbit(int x) { return x &amp; (-x); }void add(int x,int k){ for(int i=x;i&lt;=n;i+=lowbit(i)) tree[i] += k;}ll query(int x){ ll ans = 0; for(int i=x;i;i-=lowbit(i)) ans += tree[i]; return ans;}int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) a[i] = read(); for(int i=1;i&lt;=n;i++) add(i,a[i]); int opt,x,y,k; while(m--) { opt = read(); if(opt==1) { x = read(),k=read(); add(x,k); } else if(opt == 2) { x = read(),y = read(); printf(&quot;%d\\n&quot;,query(y)-query(x-1)); } } return 0;} 区间修改，单点查询区间修改用到差分数组的知识，若原数组为$a$,其差分数组为$b$，则$a[i] = b[1]+b[2]+\\cdots +b[i]$. 若要修改原数组$[l,r]$区间上的值，比如都加$2$，只需要在差分数组中$b[l]$位置$+2$，$b[r+1]$位置$-2$即可。 由于树状数组维护前缀和，所以用树状数组维护原数组，用差分数组建树状数组，查询时直接查询即可。 树状数组2 1234567891011121314151617181920212223242526272829303132333435363738394041424344int a[maxn],n,m;ll tree[maxn]; //树状数组int lowbit(int x) { return x &amp; (-x); }void add(int x,int k){ for(int i=x;i&lt;=n;i+=lowbit(i)) tree[i] += k;}ll query(int x){ ll ans = 0; for(int i=x;i;i-=lowbit(i)) ans += tree[i]; return ans;}int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) a[i] = read(); for(int i=1;i&lt;=n;i++) add(i,a[i]-a[i-1]); int opt,x,y,k; while(m--) { opt = read(); if(opt==1) { x = read(),y = read(),k=read(); add(x,k); add(y+1,-k); } else if(opt == 2) { x = read(); printf(&quot;%d\\n&quot;,query(x)); } } return 0;} 总结虽说只是模板，但是线段树这两题还是写了很久，代码量巨大。不过也比之前理解地更清楚了，虽说线段树是很有用的工具，但对于我来讲估计用上它的概率不大，用上的也写不出(太菜了)。","link":"/2021/11/03/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8E%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"title":"位运算","text":"本篇文章主要罗列一些位运算的技巧，加强记忆。 消去$x$二进制位的最后一位$1$​​​​​​ ：x&amp;(x-1) 判断$x$是否是$2$的幂 ：x&amp;(x-1)==0 判断数$x$的二进制有几个$1$ ：每次去掉最低位$1$，统计次数 两个数$a,b$，$a\\bigoplus b\\bigoplus b=a$​,一个数异或两次另一个数得到自身，由异或运算满足结合律很好理解。 不设中间值，交换两个变量$a,b$​的值 : a=a^b,b=a^b,a=a^b. a^b&lt;=a+b 例题：永夜的报应 取余操作$a\\pmod b$​，当除数$b$​为$2^n$​​​​​​​​形式，可以转化为a&amp;(b-1)​​,效率更高。 暂时想到这么多，，，","link":"/2021/11/05/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"title":"搜索题解","text":"本篇文章对一些搜索题目进行摘录。 赵子龙七进七出原题链接 题目描述 分析每隔三条边才能算作跳一步过去，一开始的想法是重新建图，利用最短路求解。但是重新建图并不方便，由于问最少前进步数，所以可以直接$bfs$.设置数组$mark[s][step]$,表示到点$s$时是隔了几步，对$s$的邻接点进行遍历，$step$变成$(step+1)\\pmod 3$.最后判断是否走到了终点，如果走到，步数除以$3$即可。 代码展开查看 >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; PI;const int maxn = 1e5+10;const ll mod = 1e9+7;inline int read(){ int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') { if (ch == '-') f = -1; ch = getchar(); } while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') { x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); ch = getchar(); } return x * f;}int n,m;int s,t;vector&lt;int&gt;g[maxn];int mark[maxn][3]; //第走到这个点是哪步int dp[maxn][3]; //走了多少步void bfs(){ queue&lt;PI&gt; q; q.push(PI(s,0)); mark[s][0] = 1; //第0步走到的点才是能跳到的点 dp[s][0] = 0; //初始步数为0 while(!q.empty()) { PI now = q.front(); q.pop(); int u = now.first,step = now.second; for(auto v:g[u]) { int ss = (step+1)%3; if(mark[v][ss]==0) { mark[v][ss] = 1; //设置标记 dp[v][ss] = dp[u][step]+1; //步数加1 q.push(PI(v,ss)); } } }}int main(){ cin&gt;&gt;n&gt;&gt;m; while(m--) { int u,v; u = read(),v = read(); g[u].push_back(v); } cin&gt;&gt;s&gt;&gt;t; bfs(); if(mark[t][0]==0) { cout&lt;&lt;-1&lt;&lt;endl; return 0; } cout&lt;&lt;dp[t][0]/3; //第0步走到，步数除以三即可 return 0;}","link":"/2021/11/08/%E6%90%9C%E7%B4%A2%E9%A2%98%E8%A7%A3/"},{"title":"Collection","text":"本篇文章记录一下学习java集合中Collection接口的内容。 $Collection$接口 $Collection$​接口是$List、Set和Queue$​​接口的父接口，该接口里定义的方法既可操作$Set$​集合，也可用于操作$List$​和$Queue$​集合。 $jdk$​不提供此接口的任何直接实现，而是提供更具体的子接口(如$Set,List$​)实现。 在$java5$​之前，$java$​集合会丢失容器中所有对象的数据类型，把所有对象都当成$Object$​类型处理；从$jdk5.0$​增加了泛型之后，$java$​集合可以记住容器中对象的数据类型。 $Iterator$​迭代器接口 $Iterator$对象称为迭代器(设计模式的一种)，主要用于遍历$Collection$集合中的元素。 $Collection$接口继承了$java.lang.Iterator$接口，该接口有一个$iterator()$方法，那么所有实现了$Collection$接口的集合类都能调用$iterator()$方法，返回一个实现了$Iterator$接口的对象。 $Iterator$​仅用于遍历集合，$Iterator$本身并不提供承装对象的能力。如果需要创建$Iterator$对象，则必须有一个被迭代的集合。 集合对象每次调用$iterator()$​方法都会得到一个全新的对象，默认指向集合第一个元素之前。 $List$接口 $List$集合类中元素有序，且可重复，集合中每个元素都有其对应的顺序索引。 List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号调用$get()$​方法取容器中的元素。 $List$接口的常用实现类有$ArrayList、LinkedList$和$Vector$​. $ArrayList$$jdk7$1ArrayList list = new ArrayList(); 在调用空参构造器时，创建了长度为$10$的$Object[]$数组$elementData$。当向$list$中增加元素达到$11$个时，数组容量不够，需要扩容，默认情况下，是扩容到原来的$1.5$倍，同时需要将原有数据中的数据复制到新的数组中。 $jdk8$​底层$Object[] elementData$​​​初始化空，当调用空参构造器时，并没有创建长度为$10$​数组。当第一次调用$add()$​时，才创建长度为$10$​的数组，并将数组添加到数组中。 这种创建对象的方式类似于单例的饿汉式，延迟了数组的创建，节省内存。 具体创建的方法为$grow()$，这也是扩容的方法。 1234567891011121314151617/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);} 可以直接调用设置数组大小的构造器public ArrayList(int initialCapacity) $ArrayList$是线程不安全的，效率较高 $LinkedList$$LinkedList$底层使用双向链表实现，内部没有声明数组，而是定义了$Node$类型的$first$和$last$,用于记录首末元素。同时定义内部类$Node$，作为保存数据的基本结构。 1234567891011private static class Node&lt;E&gt; { E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) { this.item = element; this.next = next; this.prev = prev; }} 对于频繁的插入和删除元素操作，使用$LinkedList$效率比$ArrayList$高。 $Vector$在$jdk7$和$jdk8$中创建$Vector$对象，都创建了长度为$10$​的数组。在扩容方面，默认扩容为原来数组长度的两倍。 大多数操作都和$ArrayList$​相同，区别在于$Vector$​​是线程安全的,它总是比$ArrayList$​慢，应避免使用。 $Stack$是$Vector$的子类。 $Set$接口 $Set$接口$Collection$的子接口，没有提供额外的方法，不允许包含相同的元素。 $Set$判断两个对象是否相同是根据$equals()$方法。 $HashSet$$HashSet$​的内部采用了$HashMap$​作为数据存储，$HashSet$​其实就是在操作$HashMap$​的$key$​。 1234567/** * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has * default initial capacity (16) and load factor (0.75). */public HashSet() { map = new HashMap&lt;&gt;();} $LinkedHashSet$是$HashSet$的子类，根据元素的$hashCode$​值来决定元素存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的。​ $LinkedHashSet$插入性能略低于$HashSet$，但在迭代访问$Set$全部元素时有很好的性能。","link":"/2021/11/23/Collection/"},{"title":"Map","text":"本篇文章记录学习$java$​集合中$Map$接口的内容。 $Map$接口 $Map$与$Collection$并列存在，存储具有映射关系的数据：key-value; $Map$中的$key$用$set$​来存放，不允许包含同样的值。同一个$Map$对象实现的类，必须重写$equals()$和$hashCode()$方法。 $Map$中常使用$String$作为键。 常用实现类有$HashMap、LinkedHashMap、HashTable、Properties$，子接口$SortedMap$，其实现类$TreeMap$。 $HashMap$源码中的重要常量 123456789101112//默认初始化容量为16，必须是2的n次幂static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;//最大容量为2^30static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;//默认加载因子是0.75static final float DEFAULT_LOAD_FACTOR = 0.75f;//当链表长度过长时，超过这个阈值会转化为红黑树static final int TREEIFY_THRESHOLD = 8;//当红黑树上的元素个数减少到6个是，转化为链表static final int UNTREEIFY_THRESHOLD = 6;//链表转化成红黑树时数组的最小长度，这是为了避免数组扩容和树化的冲突static final int MIN_TREEIFY_CAPACITY = 64; $jdk7$HashMap的内部存储是数组加链表的结合。当实例化一个HashMap对象时，会创建一个长度为Capacity的Entry数组，在这个数组中存放元素的位置称之为桶($bucket$​)，每个$bucket$​有自己的索引，可以根据索引找到其在数组中的位置。 关于put首先调用key所在类的hashCode()和hash方法计算key的哈希值，$jdk7$为了防止因$hash$碰撞引发的问题，在计算$hash$过程中引入随机种子，以增强$hash$的随机性，使得键值对均匀分布在桶数组中。 $hash$方法 12345678910final int hash(Object k) { int h = hashSeed; if (0 != h &amp;&amp; k instanceof String) { return sun.misc.Hashing.stringHash32((String) k); } h ^= k.hashCode(); // 通过多次位运算，提高算法散列性 h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);} 然后根据得到的$h$值和$table$的长度计算出在$table$​中的下标i=h&amp;(length-1). 如果该位置上为空，则$key-value$​添加成功。 若不为空，意味着此位置存在一个或多个数据(以链表形式存在)，需要比较$key$和已经存在的数据的哈希值。 如果$key$的哈希值与已经存在的数据的哈希值都不相同，那么$key-value$​添加成功，和原来的数据以链表的方式存储，且使用的是头插法，可能是出于后来的数据被访问到的可能性更大的出发点。 如果$key$的哈希值和已经存在的某一个数据$key1$的哈希值相同，继续调用$key$所在类的$equals()$方法比较是否相等。若不相等，则添加成功。如果相等，则用新的$value$更新原来的$value$​。 $hashMap$​​的扩容当数组中元素数量达到扩容阈值$threshold$时，需要对原数组进行扩容，这便是$resize()$。数组的大小会扩展为$16*2=32$，即扩大一倍，并且需要重新计算每个元素在数组中的位置，这是一个很消耗时间的操作。 $resize()$方法 123456789101112131415void resize(int newCapacity) { Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return; } //创建新数组 Entry[] newTable = new Entry[newCapacity]; //将原table中的元素转移到新table中 transfer(newTable, initHashSeedAsNeeded(newCapacity)); table = newTable; //重新计算扩容阈值 threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);} $transfer()$方法 12345678910111213141516//转移元素void transfer(Entry[] newTable, boolean rehash) { int newCapacity = newTable.length; for (Entry&lt;K,V&gt; e : table) { while(null != e) { Entry&lt;K,V&gt; next = e.next; if (rehash) { e.hash = null == e.key ? 0 : hash(e.key); } int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; } }} 可以看到重新计算元素在数组中的位置仍需要调用$hash()$函数，这一点在$jdk1.8$​有所改进。 为什么不直接复制到新数组中？因为数组下标计算公式为hash(key)&amp;(length-1),当数组长度变化，数组所在位置也应该变化。 头插法的弊端使用头插，当数组扩容，链表上的元素顺序会倒置，在多线程环境下可能形成环。 在多线程的环境下有可能会使链表形成环状，在$getEntry()$​​​​方法查找元素时导致死循环。 $jdk8$在$jdk8$中$hashMap$​的内部存储结构是数组+链表+红黑树的结合。$jdk8$中的数组是$Node$类型的，这与$jdk7$​不同。当初始化一个$hashMap$时，会初始化initialCapacity和loadFactor，在$put$​第一对映射关系时，会创建一个长度为initialCapacity的$Node$数组，这个长度是容量Capacity,在数组中存放元素的位置称之为桶(bucket),每个bucket有自己的索引，可根据索引查找到bucket中的元素。 为什么初始化数组长度为$16$​​当$put$一个新数据时会计算位于$table$​​数组中的下标index = hash(key)&amp;(length-1)，此处求下标使用按位与操作，如果$length-1$中某一位为$0$，那么该位按位与&amp;必然为$0$，导致数组上有些位置永远访问不到，造成空间的浪费，也增加了$hash$​冲突的可能性。而如果是$2$的$n$次幂形式，减一后低位全为$1$​，保证计算后的$index$既可以是奇数也可以是偶数，且只要传进来的$key$足够分散均匀，那么$index$就会减少重复，这样就减少了$hash$​碰撞。 为什么选$16$这个数？因为分配的太小很容易导致$Map$​扩容影响性能，初始化分配太大又会浪费资源。 加载因子$0.75$​​是时间和空间的权衡。如果小于$0.75$如$0.5$，那么数组达到一半就会扩容，空间利用率大大降低。如果大于$0.75$如$0.8$，则会增大$hash$​​冲突的概率，影响查询效率。在源码注释中有更深层次解释，大概意思是当加载因子是$0.75$的情况下，桶中$Node$结点的分布服从参数为$0.5$的泊松分布，当一个桶中出现$8$个元素的概率，已经小于千万分之一了。 12345678910111213141516171819202122232425/** Because TreeNodes are about twice the size of regular nodes, we * use them only when bins contain enough nodes to warrant use * (see TREEIFY_THRESHOLD). And when they become too small (due to * removal or resizing) they are converted back to plain bins. In * usages with well-distributed user hashCodes, tree bins are * rarely used. Ideally, under random hashCodes, the frequency of * nodes in bins follows a Poisson distribution * (http://en.wikipedia.org/wiki/Poisson_distribution) with a * parameter of about 0.5 on average for the default resizing * threshold of 0.75, although with a large variance because of * resizing granularity. Ignoring variance, the expected * occurrences of list size k are (exp(-0.5) * pow(0.5, k) / * factorial(k)). The first values are: * * 0: 0.60653066 * 1: 0.30326533 * 2: 0.07581633 * 3: 0.01263606 * 4: 0.00157952 * 5: 0.00015795 * 6: 0.00001316 * 7: 0.00000094 * 8: 0.00000006 * more: less than 1 in ten million */ $put()$​​方法123public V put(K key, V value) { return putVal(hash(key), key, value, false, true);} 当$table$为空时调用$resize()$扩容。根据当前$key$的哈希值找到在数组中的下标，并判断当前位置是否存在元素，若没有，则把$key、value$包装成$Node$节点，直接添加到此位置。若已有元素，分三种情况。 当前位置元素的$hash$值等于传过来的$hash$值，且它们的$key$​也相等，就覆盖。 如果当前已经是红黑树结果，就加入到红黑树中。 已存在元素，且是普通链表结构，则采用尾插法，把新节点加入到链表尾部。在插入过程中，若链表长度达到$8$，则转化为红黑树。 $hashMap$​​的扩容和$hash$​​方法当数组元素个数超过initialCapacity*loadFactor时，就会进行数组扩容，将数组容量扩大一倍。 $hash$方法 12345static final int hash(Object key) { int h; // &gt;&gt;&gt;无符号右移，只保留高16位 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);} 将$hashCode()$的值进行高$16$位值和低$16$值的异或运算，尽量保留高$16$位的特征，降低哈希碰撞的概率。如果不进行高低位异或运算，直接用低$16$​位和n-1相与求数组下标，那么高位不同，低位相似度较高的两个$hashCode$值得到的数组下标可能相同，高位的特征被丢失了，这样哈希碰撞的概率大大增加。而异或运算，使$0$和$1$的比例达到$1:1$的平衡状态，使结果的随机性更大。 在$resize()$​​扩大数组长度为两倍后，重新计算原数组的位置时，如果原来的$hash$值在高$1$位为$0$，那么在新数组的位置不变，如果为$1$​，则在新数组中的位置为原来的位置加上原来数组的长度。 这样在扩充时不需要像$jdk1.7$那样重新计算$hash$,只需要看看原来的$hash$新增的那个$bit$是$1$还是$0$即可，省去了重新计算$hash$的时间，这是优化的地方。 且$jdk1.7$中$rehash$时，旧链表迁移到新链表时，如果在新表的数组索引位置相同，则链表元素会倒置，可能形成环，而$jdk1.8$中使用尾插法不会使元素倒置倒置，在$resize()$​​中有所体现。 $hashMap$​​的树化在$put$数据到$hashMap$中时，如果是放到同一个位置上链表里，当链表长度达到$8$​​，会进行树化。会什么是$8$，在$jdk1.8$的源码注释中有深层次的解释，涉及泊松分布等概率知识，和上文加载因子$0.75$一致。 12if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); 但是，当数组长度小于$64$，会先进行扩容。如果数组长度达到了64，就转变为红黑树结构，结点类型由$Node$变成$TreeNode$类型。当元素被移除时，下次$resize()$方法判断树的结点个数低于$6$个，会将红黑树再转变为链表。 带参构造器当希望指定初始数组的大小时，调用了带有数组大小参数的构造器，但并不会真正创建那个长度的数组。由上文所讲，数组长度必须为$2$的$n$次幂形式。实际上会使用到$tableSizeFor()$函数，返回大于当前传入值最小的一个$2$的$n$次幂的值。 123456789101112/** * Returns a power of two size for the given target capacity. */static final int tableSizeFor(int cap) { int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;} $hashMap$​​是线程安全的吗？不是，即使在扩容时不会引起死循环，但$put()$和$get()$方法都没有加同步锁，在多线程的情况下，无法保证上一秒$put$的值，下一秒$get$的仍是原值。 $Node$节点里的$hashCode$方法。 123public final int hashCode() { return Objects.hashCode(key) ^ Objects.hashCode(value);} $LinkedHashMap$ 是$hashMap$的子类，在$hashMap$的存储结构基础上，使用了一对双向链表来记录添加元素的顺序。 和$LinkedHashSet$类似，可以维护$map$的迭代顺序与插入顺序一致。 内部类$Entry$ 123456static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; { Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) { super(hash, key, value, next); }} $TreeMap$ 存储$key-value$对时，会根据$key$进行排序。 使用自然排序，所有的$key$必须是同一个类的对象，并且实现$Comparable$接口 使用定制排序，创建$TreeMap$时需要传入一个$Comparator$对象，负责对$key$排序。 判断两个$key$相等的标准：通过$compareTo()$方法或者$compare()$方法返回$0$。 $HashTable$ 是一个古老的$Map$实现类，实现原理和$hashMap$相同，但是方法直接加上$synchronized$，是线程安全的。 $hashTable$不允许将$null$作为$key$或者$value$，而$hashMap$允许。 效率比$hashMap$​低，一般不使用。在多线程环境下会使用$ConcurrentHashMap$。","link":"/2021/11/24/Map/"}],"tags":[{"name":"experience","slug":"experience","link":"/tags/experience/"},{"name":"题解","slug":"题解","link":"/tags/%E9%A2%98%E8%A7%A3/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"acm","slug":"acm","link":"/tags/acm/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"树状数组","slug":"树状数组","link":"/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"位运算","slug":"位运算","link":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"搜索","slug":"搜索","link":"/tags/%E6%90%9C%E7%B4%A2/"},{"name":"java基础","slug":"java基础","link":"/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"java集合","slug":"java集合","link":"/tags/java%E9%9B%86%E5%90%88/"}],"categories":[{"name":"life","slug":"life","link":"/categories/life/"},{"name":"science","slug":"science","link":"/categories/science/"}]}