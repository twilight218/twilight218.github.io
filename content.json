{"pages":[],"posts":[{"title":"子数组和为k问题","text":"求一个数组中和为k的子数组的个数 如果直接暴力做，复杂度为$$O(n^2)$$,不能通过。此题考虑前缀和+哈希表优化。我们定义$$pre[i]$$为$$[0,i]$$里所有的数的和，则$$pre[i]$$由$$pre[i-1] + nums[i]$$得来，即$$pre[i] = pre[i-1]+nums[i]$$那么找到一个子数组$$[j…i]$$和为$$k$$这个条件可以转化成$$pre[j-1]==pre[i]-k$$于是问题就变为考虑以$$i$$结尾的和为$$k$$​​的连续子数组时，只要统计有多少个前缀和为$$pre[i]-k$$的$$pre[j]$$​​即可。 我们建立哈希表$$mp$$，以和为键值，到当前位置出现次数为对应值，记录$$pre[i]$$​出现的次数，从左往右边更新边计算答案，那么以$$i$$为结尾的答案$$mp[pre[i]-k]$$即可在$$O(1)$$时间内得到。最后答案即为所有$$mp[pre[i]-k]$$的和。 需要注意的是，因为我们从左往右边更新边计算时保证了$$mp[pre[i]-k]$$里记录的$$pre[j]$$​的下标范围是$$0 \\leq j \\leq i$$.同时，由于$$pre[i]$$只与前一项$$pre[j-1]$$有关，因此我们不必建前缀和数组，直接使用$$pre$$变量来记录和即可。 123456789101112int subarraySum(vector&lt;int&gt;&amp; nums,int k) { unordered_map&lt;int,int&gt; mp; int count = 0,pre = 0; mp[0] = 1; //当前前缀和就为k时是存在一个子数组的 for(auto x:nums){ pre += x; if(mp.find(pre-k) != mp.end()) count += mp[pre-k]; mp[pre]++; } return count;} 求一个数组中和为数组长度的子数组个数这个题是在训练群中听学长的面试官同事提的。咋一看比较没有思路，但是把数组每个元素减1，就变成了子数组和为0，和上题一样。 求一个数组中和为k的最长子数组长度仍然是前缀和+哈希表方式。这时哈希表以和为键，以右端点为对应值。当存在$$mp[pre[i]-k]$$时，也就是找到了一段和为$$k$$的子数组，这时比较$$maxlen$$和$$i-mp[pre-k]$$更新答案即可。 12345678910111213int maxlenOfArray(vector&lt;int&gt;&amp; nums,int k) { unordered_map&lt;int,int&gt; mp; mp[0] = -1; int maxlen = 0,pre = 0; for(int i = 0;i &lt; nums.size();i++) { pre += nums[i]; if(mp.find(pre-k)) maxlen = maxlen&gt;i-mp[pre-k]?maxlen:i-mp[pre-k]; if(mp.find(pre) == mp.end()) //总是在第一次遇到这个和时插入map，使这个值尽可能早 mp[pre] = i; } return maxlen;} 求一个01串中最长01数量相等的子串此题将$$0$$看做$$-1$$，则是找和为$$0$$的最长子串长度。 2021 CCPC Command Sequence题意一个机器人能上下左右移动，分别对应字符$$UDLR$$​.给定一个机器人移动序列字符串，问有多少个子串可以使其按照子串的顺序来走能回到原点。 分析此题我们直接将每个字符看成一个数字，且上下互为相反数，左右互为相反数，那么就是找到这个数字序列有多少个和为$$0$$的子序列。依旧是前缀和+哈希表结构。需要注意的是，由于一个$$2$$可以由两个$$-1$$​抵消，所以上下和左右代表的数字不能太接近。这里字符串长度最大为$$10^5$$，所以我们可以让$$U$$和$$D$$代表$$1$$和$$-1$$，让$$L$$和$$R$$代表$$100000$$和$$-100000$$​。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;unordered_map&gt;using namespace std;typedef long long ll;const int maxn = 1e5 + 10;int t, n;ll a[maxn];char s[maxn];int main(){ cin &gt;&gt; t; while (t--) { cin &gt;&gt; n; cin &gt;&gt; s + 1; for (int i = 1; i &lt;= n; i++) { if (s[i] == 'U') a[i] = 1; if (s[i] == 'D') a[i] = -1; if (s[i] == 'L') a[i] = 100000; if (s[i] == 'R') a[i] = -100000; } unordered_map&lt;ll, int&gt; mp; mp[0] = 1; ll pre = 0, count = 0; for (int i = 1; i &lt;= n; i++) { pre += a[i]; if (mp.find(pre) != mp.end()) count += mp[pre]; mp[pre]++; } cout &lt;&lt; count &lt;&lt; endl; } return 0;}","link":"/2021/10/21/%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E4%B8%BAk%E9%97%AE%E9%A2%98/"},{"title":"Hello Blog","text":"2021年10月21日，我终于开通了个人博客。 让我下定决心写博客的原因，是在昨天下午做到求数组中和为k的子数组个数的题目时，用到前缀和+哈希表，而这道题让我想起8月28号的CCPC网络赛F题Command Sequence也是一道前缀和+哈希表的题目，那时我却没有做出来，意识到自己已经打了将近半年的acm，知识还是很混乱的，所以下决心记录梳理一下知识。","link":"/2021/10/21/Hello-Blog/"}],"tags":[{"name":"experience","slug":"experience","link":"/tags/experience/"},{"name":"题解","slug":"题解","link":"/tags/%E9%A2%98%E8%A7%A3/"}],"categories":[{"name":"science","slug":"science","link":"/categories/science/"},{"name":"life","slug":"life","link":"/categories/life/"}]}